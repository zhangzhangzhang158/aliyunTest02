"use strict";
(self["webpackChunkrma_web"] = self["webpackChunkrma_web"] || []).push([["default-node_modules_angular_flex-layout___ivy_ngcc___esm2015_core_js"],{

/***/ 5722:
/*!************************************************************************!*\
  !*** ./node_modules/@angular/flex-layout/__ivy_ngcc__/esm2015/core.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ɵMatchMedia": function() { return /* binding */ MatchMedia; },
/* harmony export */   "ɵMockMatchMedia": function() { return /* binding */ MockMatchMedia; },
/* harmony export */   "ɵMockMatchMediaProvider": function() { return /* binding */ MockMatchMediaProvider; },
/* harmony export */   "CoreModule": function() { return /* binding */ CoreModule; },
/* harmony export */   "removeStyles": function() { return /* binding */ removeStyles; },
/* harmony export */   "BROWSER_PROVIDER": function() { return /* binding */ BROWSER_PROVIDER; },
/* harmony export */   "CLASS_NAME": function() { return /* binding */ CLASS_NAME; },
/* harmony export */   "MediaChange": function() { return /* binding */ MediaChange; },
/* harmony export */   "StylesheetMap": function() { return /* binding */ StylesheetMap; },
/* harmony export */   "DEFAULT_CONFIG": function() { return /* binding */ DEFAULT_CONFIG; },
/* harmony export */   "LAYOUT_CONFIG": function() { return /* binding */ LAYOUT_CONFIG; },
/* harmony export */   "SERVER_TOKEN": function() { return /* binding */ SERVER_TOKEN; },
/* harmony export */   "BREAKPOINT": function() { return /* binding */ BREAKPOINT; },
/* harmony export */   "mergeAlias": function() { return /* binding */ mergeAlias; },
/* harmony export */   "BaseDirective2": function() { return /* binding */ BaseDirective2; },
/* harmony export */   "DEFAULT_BREAKPOINTS": function() { return /* binding */ DEFAULT_BREAKPOINTS; },
/* harmony export */   "ScreenTypes": function() { return /* binding */ ScreenTypes; },
/* harmony export */   "ORIENTATION_BREAKPOINTS": function() { return /* binding */ ORIENTATION_BREAKPOINTS; },
/* harmony export */   "BreakPointRegistry": function() { return /* binding */ BreakPointRegistry; },
/* harmony export */   "BREAKPOINTS": function() { return /* binding */ BREAKPOINTS; },
/* harmony export */   "MediaObserver": function() { return /* binding */ MediaObserver; },
/* harmony export */   "MediaTrigger": function() { return /* binding */ MediaTrigger; },
/* harmony export */   "sortDescendingPriority": function() { return /* binding */ sortDescendingPriority; },
/* harmony export */   "sortAscendingPriority": function() { return /* binding */ sortAscendingPriority; },
/* harmony export */   "coerceArray": function() { return /* binding */ coerceArray; },
/* harmony export */   "StyleUtils": function() { return /* binding */ StyleUtils; },
/* harmony export */   "StyleBuilder": function() { return /* binding */ StyleBuilder; },
/* harmony export */   "validateBasis": function() { return /* binding */ validateBasis; },
/* harmony export */   "MediaMarshaller": function() { return /* binding */ MediaMarshaller; },
/* harmony export */   "BREAKPOINT_PRINT": function() { return /* binding */ BREAKPOINT_PRINT; },
/* harmony export */   "PrintHook": function() { return /* binding */ PrintHook; }
/* harmony export */ });
/* harmony import */ var E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js */ 5106);
/* harmony import */ var E_teams_rma_web_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/inherits.js */ 4582);
/* harmony import */ var E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createSuper.js */ 2496);
/* harmony import */ var E_teams_rma_web_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js */ 8277);
/* harmony import */ var E_teams_rma_web_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js */ 507);
/* harmony import */ var E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createClass.js */ 8047);
/* harmony import */ var E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js */ 8069);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/core */ 3184);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/common */ 6362);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ 228);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs */ 6317);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs */ 833);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs */ 6646);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! rxjs */ 9672);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! rxjs */ 745);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! rxjs */ 3280);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs/operators */ 116);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ 635);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! rxjs/operators */ 1989);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! rxjs/operators */ 2673);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! rxjs/operators */ 8951);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! rxjs/operators */ 9295);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! rxjs/operators */ 9337);








/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */




/**
 * @fileoverview added by tsickle
 * Generated from: core/browser-provider.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * Find all of the server-generated stylings, if any, and remove them
 * This will be in the form of inline classes and the style block in the
 * head of the DOM
 * @param {?} _document
 * @param {?} platformId
 * @return {?}
 */



function removeStyles(_document, platformId) {
  return (
    /**
    * @return {?}
    */
    function () {
      if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_7__.isPlatformBrowser)(platformId)) {
        /** @type {?} */
        var elements = Array.from(_document.querySelectorAll("[class*=".concat(CLASS_NAME, "]"))); // RegExp constructor should only be used if passing a variable to the constructor.
        // When using static regular expression it is more performant to use reg exp literal.
        // This is also needed to provide Safari 9 compatibility, please see
        // https://stackoverflow.com/questions/37919802 for more discussion.

        /** @type {?} */

        var classRegex = /\bflex-layout-.+?\b/g;
        elements.forEach(
        /**
        * @param {?} el
        * @return {?}
        */
        function (el) {
          el.classList.contains("".concat(CLASS_NAME, "ssr")) && el.parentNode ? el.parentNode.removeChild(el) : el.className.replace(classRegex, '');
        });
      }
    }
  );
}
/**
 *  Provider to remove SSR styles on the browser
 * @type {?}
 */


var BROWSER_PROVIDER = {
  provide:
  /** @type {?} */
  _angular_core__WEBPACK_IMPORTED_MODULE_8__.APP_BOOTSTRAP_LISTENER,
  useFactory: removeStyles,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT, _angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID],
  multi: true
};
/** @type {?} */

var CLASS_NAME = 'flex-layout-';
/**
 * @fileoverview added by tsickle
 * Generated from: core/module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * *****************************************************************
 * Define module for common Angular Layout utilities
 * *****************************************************************
 */

var CoreModule = /*#__PURE__*/(0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(function CoreModule() {
  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, CoreModule);
});

CoreModule.ɵfac = function CoreModule_Factory(t) {
  return new (t || CoreModule)();
};

CoreModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineNgModule"]({
  type: CoreModule
});
CoreModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineInjector"]({
  providers: [BROWSER_PROVIDER]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵsetClassMetadata"](CoreModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.NgModule,
    args: [{
      providers: [BROWSER_PROVIDER]
    }]
  }], null, null);
})();
/**
 * @fileoverview added by tsickle
 * Generated from: core/media-change.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * Class instances emitted [to observers] for each mql notification
 */


var MediaChange = /*#__PURE__*/function () {
  /**
   * @param {?=} matches whether the mediaQuery is currently activated
   * @param {?=} mediaQuery e.g. (min-width: 600px) and (max-width: 959px)
   * @param {?=} mqAlias e.g. gt-sm, md, gt-lg
   * @param {?=} suffix e.g. GtSM, Md, GtLg
   * @param {?=} priority the priority of activation for the given breakpoint
   */
  function MediaChange() {
    var matches = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var mediaQuery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
    var mqAlias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var priority = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, MediaChange);

    this.matches = matches;
    this.mediaQuery = mediaQuery;
    this.mqAlias = mqAlias;
    this.suffix = suffix;
    this.priority = priority;
    this.property = '';
  }
  /**
   * Create an exact copy of the MediaChange
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(MediaChange, [{
    key: "clone",
    value: function clone() {
      return new MediaChange(this.matches, this.mediaQuery, this.mqAlias, this.suffix);
    }
  }]);

  return MediaChange;
}();
/**
 * @fileoverview added by tsickle
 * Generated from: core/stylesheet-map/stylesheet-map.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * Utility to emulate a CSS stylesheet
 *
 * This utility class stores all of the styles for a given HTML element
 * as a readonly `stylesheet` map.
 */


var StylesheetMap = /*#__PURE__*/function () {
  function StylesheetMap() {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, StylesheetMap);

    this.stylesheet = new Map();
  }
  /**
   * Add an individual style to an HTML element
   * @param {?} element
   * @param {?} style
   * @param {?} value
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(StylesheetMap, [{
    key: "addStyleToElement",
    value: function addStyleToElement(element, style, value) {
      /** @type {?} */
      var stylesheet = this.stylesheet.get(element);

      if (stylesheet) {
        stylesheet.set(style, value);
      } else {
        this.stylesheet.set(element, new Map([[style, value]]));
      }
    }
    /**
     * Clear the virtual stylesheet
     * @return {?}
     */

  }, {
    key: "clearStyles",
    value: function clearStyles() {
      this.stylesheet.clear();
    }
    /**
     * Retrieve a given style for an HTML element
     * @param {?} el
     * @param {?} styleName
     * @return {?}
     */

  }, {
    key: "getStyleForElement",
    value: function getStyleForElement(el, styleName) {
      /** @type {?} */
      var styles = this.stylesheet.get(el);
      /** @type {?} */

      var value = '';

      if (styles) {
        /** @type {?} */
        var style = styles.get(styleName);

        if (typeof style === 'number' || typeof style === 'string') {
          value = style + '';
        }
      }

      return value;
    }
  }]);

  return StylesheetMap;
}();

StylesheetMap.ɵfac = function StylesheetMap_Factory(t) {
  return new (t || StylesheetMap)();
};
/** @nocollapse */


StylesheetMap.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineInjectable"])({
  factory: function StylesheetMap_Factory() {
    return new StylesheetMap();
  },
  token: StylesheetMap,
  providedIn: "root"
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵsetClassMetadata"](StylesheetMap, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [];
  }, null);
})();
/**
 * @fileoverview added by tsickle
 * Generated from: core/stylesheet-map/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: core/tokens/library-config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/** @type {?} */


var DEFAULT_CONFIG = {
  addFlexToParent: true,
  addOrientationBps: false,
  disableDefaultBps: false,
  disableVendorPrefixes: false,
  serverLoaded: false,
  useColumnBasisZero: true,
  printWithBreakpoints: [],
  mediaTriggerAutoRestore: true,
  ssrObserveBreakpoints: []
};
/** @type {?} */

var LAYOUT_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_8__.InjectionToken('Flex Layout token, config options for the library', {
  providedIn: 'root',
  factory:
  /**
  * @return {?}
  */
  function factory() {
    return DEFAULT_CONFIG;
  }
});
/**
 * @fileoverview added by tsickle
 * Generated from: core/tokens/server-token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * Token that is provided to tell whether the FlexLayoutServerModule
 * has been included in the bundle
 *
 * NOTE: This can be manually provided to disable styles when using SSR
 * @type {?}
 */

var SERVER_TOKEN = new _angular_core__WEBPACK_IMPORTED_MODULE_8__.InjectionToken('FlexLayoutServerLoaded', {
  providedIn: 'root',
  factory:
  /**
  * @return {?}
  */
  function factory() {
    return false;
  }
});
/**
 * @fileoverview added by tsickle
 * Generated from: core/tokens/breakpoint-token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/** @type {?} */

var BREAKPOINT = new _angular_core__WEBPACK_IMPORTED_MODULE_8__.InjectionToken('Flex Layout token, collect all breakpoints into one provider', {
  providedIn: 'root',
  factory:
  /**
  * @return {?}
  */
  function factory() {
    return null;
  }
});
/**
 * @fileoverview added by tsickle
 * Generated from: core/tokens/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: core/add-alias.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * For the specified MediaChange, make sure it contains the breakpoint alias
 * and suffix (if available).
 * @param {?} dest
 * @param {?} source
 * @return {?}
 */

function mergeAlias(dest, source) {
  dest = dest ? dest.clone() : new MediaChange();

  if (source) {
    dest.mqAlias = source.alias;
    dest.mediaQuery = source.mediaQuery;
    dest.suffix =
    /** @type {?} */
    source.suffix;
    dest.priority =
    /** @type {?} */
    source.priority;
  }

  return dest;
}
/**
 * @fileoverview added by tsickle
 * Generated from: utils/layout-validator.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 * @type {?}
 */


var INLINE = 'inline';
/** @type {?} */

var LAYOUT_VALUES = ['row', 'column', 'row-reverse', 'column-reverse'];
/**
 * Validate the direction|'direction wrap' value and then update the host's inline flexbox styles
 * @param {?} value
 * @return {?}
 */

function buildLayoutCSS(value) {
  var _validateValue = validateValue(value),
      _validateValue2 = (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_validateValue, 3),
      direction = _validateValue2[0],
      wrap = _validateValue2[1],
      isInline = _validateValue2[2];

  return buildCSS(direction, wrap, isInline);
}
/**
 * Validate the value to be one of the acceptable value options
 * Use default fallback of 'row'
 * @param {?} value
 * @return {?}
 */


function validateValue(value) {
  value = value ? value.toLowerCase() : '';

  var _value$split = value.split(' '),
      _value$split2 = (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_value$split, 3),
      direction = _value$split2[0],
      wrap = _value$split2[1],
      inline = _value$split2[2]; // First value must be the `flex-direction`


  if (!LAYOUT_VALUES.find(
  /**
  * @param {?} x
  * @return {?}
  */
  function (x) {
    return x === direction;
  })) {
    direction = LAYOUT_VALUES[0];
  }

  if (wrap === INLINE) {
    wrap = inline !== INLINE ? inline : '';
    inline = INLINE;
  }

  return [direction, validateWrapValue(wrap), !!inline];
}
/**
 * Convert layout-wrap='<value>' to expected flex-wrap style
 * @param {?} value
 * @return {?}
 */


function validateWrapValue(value) {
  if (!!value) {
    switch (value.toLowerCase()) {
      case 'reverse':
      case 'wrap-reverse':
      case 'reverse-wrap':
        value = 'wrap-reverse';
        break;

      case 'no':
      case 'none':
      case 'nowrap':
        value = 'nowrap';
        break;
      // All other values fallback to 'wrap'

      default:
        value = 'wrap';
        break;
    }
  }

  return value;
}
/**
 * Build the CSS that should be assigned to the element instance
 * BUG:
 *   1) min-height on a column flex container won’t apply to its flex item children in IE 10-11.
 *      Use height instead if possible; height : <xxx>vh;
 *
 *  This way any padding or border specified on the child elements are
 *  laid out and drawn inside that element's specified width and height.
 * @param {?} direction
 * @param {?=} wrap
 * @param {?=} inline
 * @return {?}
 */


function buildCSS(direction) {
  var wrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var inline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    'display': inline ? 'inline-flex' : 'flex',
    'box-sizing': 'border-box',
    'flex-direction': direction,
    'flex-wrap': !!wrap ? wrap : null
  };
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/base/base2.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @abstract
 */


var BaseDirective2 = /*#__PURE__*/function () {
  /**
   * @protected
   * @param {?} elementRef
   * @param {?} styleBuilder
   * @param {?} styler
   * @param {?} marshal
   */
  function BaseDirective2(elementRef, styleBuilder, styler, marshal) {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, BaseDirective2);

    this.elementRef = elementRef;
    this.styleBuilder = styleBuilder;
    this.styler = styler;
    this.marshal = marshal;
    this.DIRECTIVE_KEY = '';
    this.inputs = [];
    /**
     * The most recently used styles for the builder
     */

    this.mru = {};
    this.destroySubject = new rxjs__WEBPACK_IMPORTED_MODULE_9__.Subject();
    /**
     * Cache map for style computation
     */

    this.styleCache = new Map();
  }
  /**
   * Access to host element's parent DOM node
   * @protected
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(BaseDirective2, [{
    key: "parentElement",
    get: function get() {
      return this.elementRef.nativeElement.parentElement;
    }
    /**
     * Access to the HTMLElement for the directive
     * @protected
     * @return {?}
     */

  }, {
    key: "nativeElement",
    get: function get() {
      return this.elementRef.nativeElement;
    }
    /**
     * Access to the activated value for the directive
     * @return {?}
     */

  }, {
    key: "activatedValue",
    get: function get() {
      return this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    ,
    set: function set(value) {
      this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, value, this.marshal.activatedAlias);
    }
    /**
     * For \@Input changes
     * @param {?} changes
     * @return {?}
     */

  }, {
    key: "ngOnChanges",
    value: function ngOnChanges(changes) {
      var _this = this;

      Object.keys(changes).forEach(
      /**
      * @param {?} key
      * @return {?}
      */
      function (key) {
        if (_this.inputs.indexOf(key) !== -1) {
          /** @type {?} */
          var bp = key.split('.').slice(1).join('.');
          /** @type {?} */

          var val = changes[key].currentValue;

          _this.setValue(val, bp);
        }
      });
    }
    /**
     * @return {?}
     */

  }, {
    key: "ngOnDestroy",
    value: function ngOnDestroy() {
      this.destroySubject.next();
      this.destroySubject.complete();
      this.marshal.releaseElement(this.nativeElement);
    }
    /**
     * Register with central marshaller service
     * @protected
     * @param {?=} extraTriggers
     * @return {?}
     */

  }, {
    key: "init",
    value: function init() {
      var extraTriggers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.marshal.init(this.elementRef.nativeElement, this.DIRECTIVE_KEY, this.updateWithValue.bind(this), this.clearStyles.bind(this), extraTriggers);
    }
    /**
     * Add styles to the element using predefined style builder
     * @protected
     * @param {?} input
     * @param {?=} parent
     * @return {?}
     */

  }, {
    key: "addStyles",
    value: function addStyles(input, parent) {
      /** @type {?} */
      var builder = this.styleBuilder;
      /** @type {?} */

      var useCache = builder.shouldCache;
      /** @type {?} */

      var genStyles = this.styleCache.get(input);

      if (!genStyles || !useCache) {
        genStyles = builder.buildStyles(input, parent);

        if (useCache) {
          this.styleCache.set(input, genStyles);
        }
      }

      this.mru = Object.assign({}, genStyles);
      this.applyStyleToElement(genStyles);
      builder.sideEffect(input, genStyles, parent);
    }
    /**
     * Remove generated styles from an element using predefined style builder
     * @protected
     * @return {?}
     */

  }, {
    key: "clearStyles",
    value: function clearStyles() {
      var _this2 = this;

      Object.keys(this.mru).forEach(
      /**
      * @param {?} k
      * @return {?}
      */
      function (k) {
        _this2.mru[k] = '';
      });
      this.applyStyleToElement(this.mru);
      this.mru = {};
    }
    /**
     * Force trigger style updates on DOM element
     * @protected
     * @return {?}
     */

  }, {
    key: "triggerUpdate",
    value: function triggerUpdate() {
      this.marshal.triggerUpdate(this.nativeElement, this.DIRECTIVE_KEY);
    }
    /**
     * Determine the DOM element's Flexbox flow (flex-direction).
     *
     * Check inline style first then check computed (stylesheet) style.
     * And optionally add the flow value to element's inline style.
     * @protected
     * @param {?} target
     * @param {?=} addIfMissing
     * @return {?}
     */

  }, {
    key: "getFlexFlowDirection",
    value: function getFlexFlowDirection(target) {
      var addIfMissing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (target) {
        var _this$styler$getFlowD = this.styler.getFlowDirection(target),
            _this$styler$getFlowD2 = (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_this$styler$getFlowD, 2),
            value = _this$styler$getFlowD2[0],
            hasInlineValue = _this$styler$getFlowD2[1];

        if (!hasInlineValue && addIfMissing) {
          /** @type {?} */
          var style = buildLayoutCSS(value);
          /** @type {?} */

          var elements = [target];
          this.styler.applyStyleToElements(style, elements);
        }

        return value.trim();
      }

      return 'row';
    }
    /**
     * @protected
     * @param {?} target
     * @return {?}
     */

  }, {
    key: "hasWrap",
    value: function hasWrap(target) {
      return this.styler.hasWrap(target);
    }
    /**
     * Applies styles given via string pair or object map to the directive element
     * @protected
     * @param {?} style
     * @param {?=} value
     * @param {?=} element
     * @return {?}
     */

  }, {
    key: "applyStyleToElement",
    value: function applyStyleToElement(style, value) {
      var element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.nativeElement;
      this.styler.applyStyleToElement(element, style, value);
    }
    /**
     * @protected
     * @param {?} val
     * @param {?} bp
     * @return {?}
     */

  }, {
    key: "setValue",
    value: function setValue(val, bp) {
      this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, val, bp);
    }
    /**
     * @protected
     * @param {?} input
     * @return {?}
     */

  }, {
    key: "updateWithValue",
    value: function updateWithValue(input) {
      if (this.currentValue !== input) {
        this.addStyles(input);
        this.currentValue = input;
      }
    }
  }]);

  return BaseDirective2;
}();

BaseDirective2.ɵfac = function BaseDirective2_Factory(t) {
  _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinvalidFactory"]();
};

BaseDirective2.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineDirective"]({
  type: BaseDirective2,
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵNgOnChangesFeature"]]
});
/**
 * @fileoverview added by tsickle
 * Generated from: core/base/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: core/breakpoints/data/break-points.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * NOTE: Smaller ranges have HIGHER priority since the match is more specific
 * @type {?}
 */

var DEFAULT_BREAKPOINTS = [{
  alias: 'xs',
  mediaQuery: 'screen and (min-width: 0px) and (max-width: 599.9px)',
  priority: 1000
}, {
  alias: 'sm',
  mediaQuery: 'screen and (min-width: 600px) and (max-width: 959.9px)',
  priority: 900
}, {
  alias: 'md',
  mediaQuery: 'screen and (min-width: 960px) and (max-width: 1279.9px)',
  priority: 800
}, {
  alias: 'lg',
  mediaQuery: 'screen and (min-width: 1280px) and (max-width: 1919.9px)',
  priority: 700
}, {
  alias: 'xl',
  mediaQuery: 'screen and (min-width: 1920px) and (max-width: 4999.9px)',
  priority: 600
}, {
  alias: 'lt-sm',
  overlapping: true,
  mediaQuery: 'screen and (max-width: 599.9px)',
  priority: 950
}, {
  alias: 'lt-md',
  overlapping: true,
  mediaQuery: 'screen and (max-width: 959.9px)',
  priority: 850
}, {
  alias: 'lt-lg',
  overlapping: true,
  mediaQuery: 'screen and (max-width: 1279.9px)',
  priority: 750
}, {
  alias: 'lt-xl',
  overlapping: true,
  priority: 650,
  mediaQuery: 'screen and (max-width: 1919.9px)'
}, {
  alias: 'gt-xs',
  overlapping: true,
  mediaQuery: 'screen and (min-width: 600px)',
  priority: -950
}, {
  alias: 'gt-sm',
  overlapping: true,
  mediaQuery: 'screen and (min-width: 960px)',
  priority: -850
}, {
  alias: 'gt-md',
  overlapping: true,
  mediaQuery: 'screen and (min-width: 1280px)',
  priority: -750
}, {
  alias: 'gt-lg',
  overlapping: true,
  mediaQuery: 'screen and (min-width: 1920px)',
  priority: -650
}];
/**
 * @fileoverview added by tsickle
 * Generated from: core/breakpoints/data/orientation-break-points.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/* tslint:disable */

/** @type {?} */

var HANDSET_PORTRAIT = '(orientation: portrait) and (max-width: 599.9px)';
/** @type {?} */

var HANDSET_LANDSCAPE = '(orientation: landscape) and (max-width: 959.9px)';
/** @type {?} */

var TABLET_PORTRAIT = '(orientation: portrait) and (min-width: 600px) and (max-width: 839.9px)';
/** @type {?} */

var TABLET_LANDSCAPE = '(orientation: landscape) and (min-width: 960px) and (max-width: 1279.9px)';
/** @type {?} */

var WEB_PORTRAIT = '(orientation: portrait) and (min-width: 840px)';
/** @type {?} */

var WEB_LANDSCAPE = '(orientation: landscape) and (min-width: 1280px)';
/** @type {?} */

var ScreenTypes = {
  'HANDSET': "".concat(HANDSET_PORTRAIT, ", ").concat(HANDSET_LANDSCAPE),
  'TABLET': "".concat(TABLET_PORTRAIT, " , ").concat(TABLET_LANDSCAPE),
  'WEB': "".concat(WEB_PORTRAIT, ", ").concat(WEB_LANDSCAPE, " "),
  'HANDSET_PORTRAIT': "".concat(HANDSET_PORTRAIT),
  'TABLET_PORTRAIT': "".concat(TABLET_PORTRAIT, " "),
  'WEB_PORTRAIT': "".concat(WEB_PORTRAIT),
  'HANDSET_LANDSCAPE': "".concat(HANDSET_LANDSCAPE),
  'TABLET_LANDSCAPE': "".concat(TABLET_LANDSCAPE),
  'WEB_LANDSCAPE': "".concat(WEB_LANDSCAPE)
};
/**
 * Extended Breakpoints for handset/tablets with landscape or portrait orientations
 * @type {?}
 */

var ORIENTATION_BREAKPOINTS = [{
  'alias': 'handset',
  priority: 2000,
  'mediaQuery': ScreenTypes.HANDSET
}, {
  'alias': 'handset.landscape',
  priority: 2000,
  'mediaQuery': ScreenTypes.HANDSET_LANDSCAPE
}, {
  'alias': 'handset.portrait',
  priority: 2000,
  'mediaQuery': ScreenTypes.HANDSET_PORTRAIT
}, {
  'alias': 'tablet',
  priority: 2100,
  'mediaQuery': ScreenTypes.TABLET
}, {
  'alias': 'tablet.landscape',
  priority: 2100,
  'mediaQuery': ScreenTypes.TABLET_LANDSCAPE
}, {
  'alias': 'tablet.portrait',
  priority: 2100,
  'mediaQuery': ScreenTypes.TABLET_PORTRAIT
}, {
  'alias': 'web',
  priority: 2200,
  'mediaQuery': ScreenTypes.WEB,
  overlapping: true
}, {
  'alias': 'web.landscape',
  priority: 2200,
  'mediaQuery': ScreenTypes.WEB_LANDSCAPE,
  overlapping: true
}, {
  'alias': 'web.portrait',
  priority: 2200,
  'mediaQuery': ScreenTypes.WEB_PORTRAIT,
  overlapping: true
}];
/**
 * @fileoverview added by tsickle
 * Generated from: core/breakpoints/break-point.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: utils/object-extend.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * Extends an object with the *enumerable* and *own* properties of one or more source objects,
 * similar to Object.assign.
 *
 * @param {?} dest The object which will have properties copied to it.
 * @param {...?} sources The source objects from which properties will be copied.
 * @return {?}
 */

function extendObject(dest) {
  if (dest == null) {
    throw TypeError('Cannot convert undefined or null to object');
  }

  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {
    var source = _sources[_i];

    if (source != null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          dest[key] = source[key];
        }
      }
    }
  }

  return dest;
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/breakpoints/breakpoint-tools.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/** @type {?} */


var ALIAS_DELIMITERS = /(\.|-|_)/g;
/**
 * @param {?} part
 * @return {?}
 */

function firstUpperCase(part) {
  /** @type {?} */
  var first = part.length > 0 ? part.charAt(0) : '';
  /** @type {?} */

  var remainder = part.length > 1 ? part.slice(1) : '';
  return first.toUpperCase() + remainder;
}
/**
 * Converts snake-case to SnakeCase.
 * @param {?} name Text to UpperCamelCase
 * @return {?}
 */


function camelCase(name) {
  return name.replace(ALIAS_DELIMITERS, '|').split('|').map(firstUpperCase).join('');
}
/**
 * For each breakpoint, ensure that a Suffix is defined;
 * fallback to UpperCamelCase the unique Alias value
 * @param {?} list
 * @return {?}
 */


function validateSuffixes(list) {
  list.forEach(
  /**
  * @param {?} bp
  * @return {?}
  */
  function (bp) {
    if (!bp.suffix) {
      bp.suffix = camelCase(bp.alias); // create Suffix value based on alias

      bp.overlapping = !!bp.overlapping; // ensure default value
    }
  });
  return list;
}
/**
 * Merge a custom breakpoint list with the default list based on unique alias values
 *  - Items are added if the alias is not in the default list
 *  - Items are merged with the custom override if the alias exists in the default list
 * @param {?} defaults
 * @param {?=} custom
 * @return {?}
 */


function mergeByAlias(defaults) {
  var custom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  /** @type {?} */
  var dict = {};
  defaults.forEach(
  /**
  * @param {?} bp
  * @return {?}
  */
  function (bp) {
    dict[bp.alias] = bp;
  }); // Merge custom breakpoints

  custom.forEach(
  /**
  * @param {?} bp
  * @return {?}
  */
  function (bp) {
    if (dict[bp.alias]) {
      extendObject(dict[bp.alias], bp);
    } else {
      dict[bp.alias] = bp;
    }
  });
  return validateSuffixes(Object.keys(dict).map(
  /**
  * @param {?} k
  * @return {?}
  */
  function (k) {
    return dict[k];
  }));
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/breakpoints/break-points-token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 *  Injection token unique to the flex-layout library.
 *  Use this token when build a custom provider (see below).
 * @type {?}
 */


var BREAKPOINTS = new _angular_core__WEBPACK_IMPORTED_MODULE_8__.InjectionToken('Token (@angular/flex-layout) Breakpoints', {
  providedIn: 'root',
  factory:
  /**
  * @return {?}
  */
  function factory() {
    /** @type {?} */
    var breakpoints = (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__.inject)(BREAKPOINT);
    /** @type {?} */

    var layoutConfig = (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__.inject)(LAYOUT_CONFIG);
    /** @type {?} */

    var bpFlattenArray = [].concat.apply([], (breakpoints || []).map(
    /**
    * @param {?} v
    * @return {?}
    */
    function (v) {
      return Array.isArray(v) ? v : [v];
    }));
    /** @type {?} */

    var builtIns = (layoutConfig.disableDefaultBps ? [] : DEFAULT_BREAKPOINTS).concat(layoutConfig.addOrientationBps ? ORIENTATION_BREAKPOINTS : []);
    return mergeByAlias(builtIns, bpFlattenArray);
  }
});
/**
 * @fileoverview added by tsickle
 * Generated from: core/utils/sort.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * HOF to sort the breakpoints by descending priority
 * @template T
 * @param {?} a
 * @param {?} b
 * @return {?}
 */

function sortDescendingPriority(a, b) {
  /** @type {?} */
  var priorityA = a ? a.priority || 0 : 0;
  /** @type {?} */

  var priorityB = b ? b.priority || 0 : 0;
  return priorityB - priorityA;
}
/**
 * HOF to sort the breakpoints by ascending priority
 * @template T
 * @param {?} a
 * @param {?} b
 * @return {?}
 */


function sortAscendingPriority(a, b) {
  /** @type {?} */
  var pA = a.priority || 0;
  /** @type {?} */

  var pB = b.priority || 0;
  return pA - pB;
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/breakpoints/break-point-registry.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * Registry of 1..n MediaQuery breakpoint ranges
 * This is published as a provider and may be overridden from custom, application-specific ranges
 *
 */


var BreakPointRegistry = /*#__PURE__*/function () {
  /**
   * @param {?} list
   */
  function BreakPointRegistry(list) {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, BreakPointRegistry);

    /**
     * Memoized BreakPoint Lookups
     */
    this.findByMap = new Map();
    this.items = (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(list).sort(sortAscendingPriority);
  }
  /**
   * Search breakpoints by alias (e.g. gt-xs)
   * @param {?} alias
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(BreakPointRegistry, [{
    key: "findByAlias",
    value: function findByAlias(alias) {
      return !alias ? null : this.findWithPredicate(alias,
      /**
      * @param {?} bp
      * @return {?}
      */
      function (bp) {
        return bp.alias == alias;
      });
    }
    /**
     * @param {?} query
     * @return {?}
     */

  }, {
    key: "findByQuery",
    value: function findByQuery(query) {
      return this.findWithPredicate(query,
      /**
      * @param {?} bp
      * @return {?}
      */
      function (bp) {
        return bp.mediaQuery == query;
      });
    }
    /**
     * Get all the breakpoints whose ranges could overlapping `normal` ranges;
     * e.g. gt-sm overlaps md, lg, and xl
     * @return {?}
     */

  }, {
    key: "overlappings",
    get: function get() {
      return this.items.filter(
      /**
      * @param {?} it
      * @return {?}
      */
      function (it) {
        return it.overlapping == true;
      });
    }
    /**
     * Get list of all registered (non-empty) breakpoint aliases
     * @return {?}
     */

  }, {
    key: "aliases",
    get: function get() {
      return this.items.map(
      /**
      * @param {?} it
      * @return {?}
      */
      function (it) {
        return it.alias;
      });
    }
    /**
     * Aliases are mapped to properties using suffixes
     * e.g.  'gt-sm' for property 'layout'  uses suffix 'GtSm'
     * for property layoutGtSM.
     * @return {?}
     */

  }, {
    key: "suffixes",
    get: function get() {
      return this.items.map(
      /**
      * @param {?} it
      * @return {?}
      */
      function (it) {
        return !!it.suffix ? it.suffix : '';
      });
    }
    /**
     * Memoized lookup using custom predicate function
     * @private
     * @param {?} key
     * @param {?} searchFn
     * @return {?}
     */

  }, {
    key: "findWithPredicate",
    value: function findWithPredicate(key, searchFn) {
      /** @type {?} */
      var response = this.findByMap.get(key);

      if (!response) {
        response = this.items.find(searchFn) || null;
        this.findByMap.set(key, response);
      }

      return response || null;
    }
  }]);

  return BreakPointRegistry;
}();

BreakPointRegistry.ɵfac = function BreakPointRegistry_Factory(t) {
  return new (t || BreakPointRegistry)(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](BREAKPOINTS));
};
/** @nocollapse */


BreakPointRegistry.ctorParameters = function () {
  return [{
    type: Array,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [BREAKPOINTS]
    }]
  }];
};
/** @nocollapse */


BreakPointRegistry.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineInjectable"])({
  factory: function BreakPointRegistry_Factory() {
    return new BreakPointRegistry((0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(BREAKPOINTS));
  },
  token: BreakPointRegistry,
  providedIn: "root"
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵsetClassMetadata"](BreakPointRegistry, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: Array,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [BREAKPOINTS]
      }]
    }];
  }, null);
})();
/**
 * @fileoverview added by tsickle
 * Generated from: core/breakpoints/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: core/match-media/match-media.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * MediaMonitor configures listeners to mediaQuery changes and publishes an Observable facade to
 * convert mediaQuery change callbacks to subscriber notifications. These notifications will be
 * performed within the ng Zone to trigger change detections and component updates.
 *
 * NOTE: both mediaQuery activations and de-activations are announced in notifications
 */


var MatchMedia = /*#__PURE__*/function () {
  /**
   * @param {?} _zone
   * @param {?} _platformId
   * @param {?} _document
   */
  function MatchMedia(_zone, _platformId, _document) {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, MatchMedia);

    this._zone = _zone;
    this._platformId = _platformId;
    this._document = _document;
    /**
     * Initialize source with 'all' so all non-responsive APIs trigger style updates
     */

    this.source = new rxjs__WEBPACK_IMPORTED_MODULE_10__.BehaviorSubject(new MediaChange(true));
    this.registry = new Map();
    this.pendingRemoveListenerFns = [];
    this._observable$ = this.source.asObservable();
  }
  /**
   * Publish list of all current activations
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(MatchMedia, [{
    key: "activations",
    get: function get() {
      /** @type {?} */
      var results = [];
      this.registry.forEach(
      /**
      * @param {?} mql
      * @param {?} key
      * @return {?}
      */
      function (mql, key) {
        if (mql.matches) {
          results.push(key);
        }
      });
      return results;
    }
    /**
     * For the specified mediaQuery?
     * @param {?} mediaQuery
     * @return {?}
     */

  }, {
    key: "isActive",
    value: function isActive(mediaQuery) {
      /** @type {?} */
      var mql = this.registry.get(mediaQuery);
      return !!mql ? mql.matches : this.registerQuery(mediaQuery).some(
      /**
      * @param {?} m
      * @return {?}
      */
      function (m) {
        return m.matches;
      });
    }
    /**
     * External observers can watch for all (or a specific) mql changes.
     * Typically used by the MediaQueryAdaptor; optionally available to components
     * who wish to use the MediaMonitor as mediaMonitor$ observable service.
     *
     * Use deferred registration process to register breakpoints only on subscription
     * This logic also enforces logic to register all mediaQueries BEFORE notify
     * subscribers of notifications.
     * @param {?=} mqList
     * @param {?=} filterOthers
     * @return {?}
     */

  }, {
    key: "observe",
    value: function observe(mqList) {
      var _this3 = this;

      var filterOthers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (mqList && mqList.length) {
        /** @type {?} */
        var matchMedia$ = this._observable$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(
        /**
        * @param {?} change
        * @return {?}
        */
        function (change) {
          return !filterOthers ? true : mqList.indexOf(change.mediaQuery) > -1;
        }));
        /** @type {?} */


        var registration$ = new rxjs__WEBPACK_IMPORTED_MODULE_12__.Observable(
        /**
        * @param {?} observer
        * @return {?}
        */
        function (observer) {
          // tslint:disable-line:max-line-length

          /** @type {?} */
          var matches = _this3.registerQuery(mqList);

          if (matches.length) {
            /** @type {?} */
            var lastChange =
            /** @type {?} */
            matches.pop();
            matches.forEach(
            /**
            * @param {?} e
            * @return {?}
            */
            function (e) {
              observer.next(e);
            });

            _this3.source.next(lastChange); // last match is cached

          }

          observer.complete();
        });
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_13__.merge)(registration$, matchMedia$);
      }

      return this._observable$;
    }
    /**
     * Based on the BreakPointRegistry provider, register internal listeners for each unique
     * mediaQuery. Each listener emits specific MediaChange data to observers
     * @param {?} mediaQuery
     * @return {?}
     */

  }, {
    key: "registerQuery",
    value: function registerQuery(mediaQuery) {
      var _this4 = this;

      /** @type {?} */
      var list = Array.isArray(mediaQuery) ? mediaQuery : [mediaQuery];
      /** @type {?} */

      var matches = [];
      buildQueryCss(list, this._document);
      list.forEach(
      /**
      * @param {?} query
      * @return {?}
      */
      function (query) {
        /** @type {?} */
        var onMQLEvent =
        /**
        * @param {?} e
        * @return {?}
        */
        function onMQLEvent(e) {
          _this4._zone.run(
          /**
          * @return {?}
          */
          function () {
            return _this4.source.next(new MediaChange(e.matches, query));
          });
        };
        /** @type {?} */


        var mql = _this4.registry.get(query);

        if (!mql) {
          mql = _this4.buildMQL(query);
          mql.addListener(onMQLEvent);

          _this4.pendingRemoveListenerFns.push(
          /**
          * @return {?}
          */
          function () {
            return (
              /** @type {?} */
              mql.removeListener(onMQLEvent)
            );
          });

          _this4.registry.set(query, mql);
        }

        if (mql.matches) {
          matches.push(new MediaChange(true, query));
        }
      });
      return matches;
    }
    /**
     * @return {?}
     */

  }, {
    key: "ngOnDestroy",
    value: function ngOnDestroy() {
      /** @type {?} */
      var fn;

      while (fn = this.pendingRemoveListenerFns.pop()) {
        fn();
      }
    }
    /**
     * Call window.matchMedia() to build a MediaQueryList; which
     * supports 0..n listeners for activation/deactivation
     * @protected
     * @param {?} query
     * @return {?}
     */

  }, {
    key: "buildMQL",
    value: function buildMQL(query) {
      return constructMql(query, (0,_angular_common__WEBPACK_IMPORTED_MODULE_7__.isPlatformBrowser)(this._platformId));
    }
  }]);

  return MatchMedia;
}();

MatchMedia.ɵfac = function MatchMedia_Factory(t) {
  return new (t || MatchMedia)(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_8__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT));
};
/** @nocollapse */


MatchMedia.ctorParameters = function () {
  return [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.NgZone
  }, {
    type: Object,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT]
    }]
  }];
};
/** @nocollapse */


MatchMedia.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineInjectable"])({
  factory: function MatchMedia_Factory() {
    return new MatchMedia((0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_8__.NgZone), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT));
  },
  token: MatchMedia,
  providedIn: "root"
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵsetClassMetadata"](MatchMedia, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.NgZone
    }, {
      type: Object,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT]
      }]
    }];
  }, null);
})();
/**
 * Private global registry for all dynamically-created, injected style tags
 * @see prepare(query)
 * @type {?}
 */


var ALL_STYLES = {};
/**
 * For Webkit engines that only trigger the MediaQueryList Listener
 * when there is at least one CSS selector for the respective media query.
 *
 * @param {?} mediaQueries
 * @param {?} _document
 * @return {?}
 */

function buildQueryCss(mediaQueries, _document) {
  /** @type {?} */
  var list = mediaQueries.filter(
  /**
  * @param {?} it
  * @return {?}
  */
  function (it) {
    return !ALL_STYLES[it];
  });

  if (list.length > 0) {
    /** @type {?} */
    var query = list.join(', ');

    try {
      /** @type {?} */
      var styleEl = _document.createElement('style');

      styleEl.setAttribute('type', 'text/css');

      if (!
      /** @type {?} */
      styleEl.styleSheet) {
        /** @type {?} */
        var cssText = "\n/*\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\n  see http://bit.ly/2sd4HMP\n*/\n@media ".concat(query, " {.fx-query-test{ }}\n");
        styleEl.appendChild(_document.createTextNode(cssText));
      }

      /** @type {?} */
      _document.head.appendChild(styleEl); // Store in private global registry


      list.forEach(
      /**
      * @param {?} mq
      * @return {?}
      */
      function (mq) {
        return ALL_STYLES[mq] = styleEl;
      });
    } catch (e) {
      console.error(e);
    }
  }
}
/**
 * @param {?} query
 * @param {?} isBrowser
 * @return {?}
 */


function constructMql(query, isBrowser) {
  /** @type {?} */
  var canListen = isBrowser && !!
  /** @type {?} */
  window.matchMedia('all').addListener;
  return canListen ?
  /** @type {?} */
  window.matchMedia(query) :
  /** @type {?} */
  {
    matches: query === 'all' || query === '',
    media: query,
    addListener:
    /**
    * @return {?}
    */
    function addListener() {},
    removeListener:
    /**
    * @return {?}
    */
    function removeListener() {},
    onchange: null,

    /**
     * @return {?}
     */
    addEventListener: function addEventListener() {},

    /**
     * @return {?}
     */
    removeEventListener: function removeEventListener() {},

    /**
     * @return {?}
     */
    dispatchEvent: function dispatchEvent() {
      return false;
    }
  };
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/match-media/mock/mock-match-media.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * MockMatchMedia mocks calls to the Window API matchMedia with a build of a simulated
 * MockMediaQueryListener. Methods are available to simulate an activation of a mediaQuery
 * range and to clearAll mediaQuery listeners.
 */


var MockMatchMedia = /*#__PURE__*/function (_MatchMedia) {
  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_1__["default"])(MockMatchMedia, _MatchMedia);

  var _super = (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(MockMatchMedia);

  // Allow fallback to overlapping mediaQueries

  /**
   * @param {?} _zone
   * @param {?} _platformId
   * @param {?} _document
   * @param {?} _breakpoints
   */
  function MockMatchMedia(_zone, _platformId, _document, _breakpoints) {
    var _this5;

    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, MockMatchMedia);

    _this5 = _super.call(this, _zone, _platformId, _document);
    _this5._breakpoints = _breakpoints;
    _this5.autoRegisterQueries = true; // Used for testing BreakPoint registrations
    // Used for testing BreakPoint registrations

    _this5.useOverlaps = false; // Allow fallback to overlapping mediaQueries

    return _this5;
  }
  /**
   * Easy method to clear all listeners for all mediaQueries
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(MockMatchMedia, [{
    key: "clearAll",
    value: function clearAll() {
      this.registry.forEach(
      /**
      * @param {?} mql
      * @return {?}
      */
      function (mql) {
        /** @type {?} */
        mql.destroy();
      });
      this.registry.clear();
      this.useOverlaps = false;
    }
    /**
     * Feature to support manual, simulated activation of a mediaQuery.
     * @param {?} mediaQuery
     * @param {?=} useOverlaps
     * @return {?}
     */

  }, {
    key: "activate",
    value: function activate(mediaQuery) {
      var useOverlaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      useOverlaps = useOverlaps || this.useOverlaps;
      mediaQuery = this._validateQuery(mediaQuery);

      if (useOverlaps || !this.isActive(mediaQuery)) {
        this._deactivateAll();

        this._registerMediaQuery(mediaQuery);

        this._activateWithOverlaps(mediaQuery, useOverlaps);
      }

      return this.hasActivated;
    }
    /**
     * Converts an optional mediaQuery alias to a specific, valid mediaQuery
     * @param {?} queryOrAlias
     * @return {?}
     */

  }, {
    key: "_validateQuery",
    value: function _validateQuery(queryOrAlias) {
      /** @type {?} */
      var bp = this._breakpoints.findByAlias(queryOrAlias);

      return bp && bp.mediaQuery || queryOrAlias;
    }
    /**
     * Manually onMediaChange any overlapping mediaQueries to simulate
     * similar functionality in the window.matchMedia()
     * @private
     * @param {?} mediaQuery
     * @param {?} useOverlaps
     * @return {?}
     */

  }, {
    key: "_activateWithOverlaps",
    value: function _activateWithOverlaps(mediaQuery, useOverlaps) {
      if (useOverlaps) {
        /** @type {?} */
        var bp = this._breakpoints.findByQuery(mediaQuery);
        /** @type {?} */


        var alias = bp ? bp.alias : 'unknown'; // Simulate activation of overlapping lt-<XXX> ranges

        switch (alias) {
          case 'lg':
            this._activateByAlias('lt-xl');

            break;

          case 'md':
            this._activateByAlias('lt-xl, lt-lg');

            break;

          case 'sm':
            this._activateByAlias('lt-xl, lt-lg, lt-md');

            break;

          case 'xs':
            this._activateByAlias('lt-xl, lt-lg, lt-md, lt-sm');

            break;
        } // Simulate activation of overlapping gt-<xxxx> mediaQuery ranges


        switch (alias) {
          case 'xl':
            this._activateByAlias('gt-lg, gt-md, gt-sm, gt-xs');

            break;

          case 'lg':
            this._activateByAlias('gt-md, gt-sm, gt-xs');

            break;

          case 'md':
            this._activateByAlias('gt-sm, gt-xs');

            break;

          case 'sm':
            this._activateByAlias('gt-xs');

            break;
        }
      } // Activate last since the responsiveActivation is watching *this* mediaQuery


      return this._activateByQuery(mediaQuery);
    }
    /**
     *
     * @private
     * @param {?} aliases
     * @return {?}
     */

  }, {
    key: "_activateByAlias",
    value: function _activateByAlias(aliases) {
      var _this6 = this;

      /** @type {?} */
      var activate =
      /**
      * @param {?} alias
      * @return {?}
      */
      function activate(alias) {
        /** @type {?} */
        var bp = _this6._breakpoints.findByAlias(alias);

        _this6._activateByQuery(bp ? bp.mediaQuery : alias);
      };

      aliases.split(',').forEach(
      /**
      * @param {?} alias
      * @return {?}
      */
      function (alias) {
        return activate(alias.trim());
      });
    }
    /**
     *
     * @private
     * @param {?} mediaQuery
     * @return {?}
     */

  }, {
    key: "_activateByQuery",
    value: function _activateByQuery(mediaQuery) {
      /** @type {?} */
      var mql =
      /** @type {?} */
      this.registry.get(mediaQuery);

      if (mql && !this.isActive(mediaQuery)) {
        this.registry.set(mediaQuery, mql.activate());
      }

      return this.hasActivated;
    }
    /**
     * Deactivate all current MQLs and reset the buffer
     * @private
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */

  }, {
    key: "_deactivateAll",
    value: function _deactivateAll() {
      /** @type {?} */
      this.registry.forEach(
      /**
      * @param {?} it
      * @return {?}
      */
      function (it) {
        /** @type {?} */
        it.deactivate();
      });
      return (
        /** @type {?} */
        this
      );
    }
    /**
     * Insure the mediaQuery is registered with MatchMedia
     * @private
     * @param {?} mediaQuery
     * @return {?}
     */

  }, {
    key: "_registerMediaQuery",
    value: function _registerMediaQuery(mediaQuery) {
      if (!this.registry.has(mediaQuery) && this.autoRegisterQueries) {
        this.registerQuery(mediaQuery);
      }
    }
    /**
     * Call window.matchMedia() to build a MediaQueryList; which
     * supports 0..n listeners for activation/deactivation
     * @protected
     * @param {?} query
     * @return {?}
     */

  }, {
    key: "buildMQL",
    value: function buildMQL(query) {
      return new MockMediaQueryList(query);
    }
    /**
     * @protected
     * @return {?}
     */

  }, {
    key: "hasActivated",
    get: function get() {
      return this.activations.length > 0;
    }
  }]);

  return MockMatchMedia;
}(MatchMedia);

MockMatchMedia.ɵfac = function MockMatchMedia_Factory(t) {
  return new (t || MockMatchMedia)(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_8__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](BreakPointRegistry));
};

MockMatchMedia.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineInjectable"]({
  token: MockMatchMedia,
  factory: MockMatchMedia.ɵfac
});
/** @nocollapse */

MockMatchMedia.ctorParameters = function () {
  return [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.NgZone
  }, {
    type: Object,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT]
    }]
  }, {
    type: BreakPointRegistry
  }];
};

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵsetClassMetadata"](MockMatchMedia, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Injectable
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.NgZone
    }, {
      type: Object,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT]
      }]
    }, {
      type: BreakPointRegistry
    }];
  }, null);
})();
/**
 * Special internal class to simulate a MediaQueryList and
 * - supports manual activation to simulate mediaQuery matching
 * - manages listeners
 */


var MockMediaQueryList = /*#__PURE__*/function () {
  /**
   * @param {?} _mediaQuery
   */
  function MockMediaQueryList(_mediaQuery) {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, MockMediaQueryList);

    this._mediaQuery = _mediaQuery;
    this._isActive = false;
    this._listeners = [];
    this.onchange = null;
  }
  /**
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(MockMediaQueryList, [{
    key: "matches",
    get: function get() {
      return this._isActive;
    }
    /**
     * @return {?}
     */

  }, {
    key: "media",
    get: function get() {
      return this._mediaQuery;
    }
    /**
     * Destroy the current list by deactivating the
     * listeners and clearing the internal list
     * @return {?}
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.deactivate();
      this._listeners = [];
    }
    /**
     * Notify all listeners that 'matches === TRUE'
     * @return {?}
     */

  }, {
    key: "activate",
    value: function activate() {
      var _this7 = this;

      if (!this._isActive) {
        this._isActive = true;

        this._listeners.forEach(
        /**
        * @param {?} callback
        * @return {?}
        */
        function (callback) {
          /** @type {?} */
          var cb =
          /** @type {?} */
          callback;
          cb.call(_this7,
          /** @type {?} */
          {
            matches: _this7.matches,
            media: _this7.media
          });
        });
      }

      return this;
    }
    /**
     * Notify all listeners that 'matches === false'
     * @return {?}
     */

  }, {
    key: "deactivate",
    value: function deactivate() {
      var _this8 = this;

      if (this._isActive) {
        this._isActive = false;

        this._listeners.forEach(
        /**
        * @param {?} callback
        * @return {?}
        */
        function (callback) {
          /** @type {?} */
          var cb =
          /** @type {?} */
          callback;
          cb.call(_this8,
          /** @type {?} */
          {
            matches: _this8.matches,
            media: _this8.media
          });
        });
      }

      return this;
    }
    /**
     * Add a listener to our internal list to activate later
     * @param {?} listener
     * @return {?}
     */

  }, {
    key: "addListener",
    value: function addListener(listener) {
      if (this._listeners.indexOf(listener) === -1) {
        this._listeners.push(listener);
      }

      if (this._isActive) {
        /** @type {?} */
        var cb =
        /** @type {?} */
        listener;
        cb.call(this,
        /** @type {?} */
        {
          matches: this.matches,
          media: this.media
        });
      }
    }
    /**
     * Don't need to remove listeners in the testing environment
     * @param {?} _
     * @return {?}
     */

  }, {
    key: "removeListener",
    value: function removeListener(_) {}
    /**
     * @param {?} _
     * @param {?} __
     * @param {?=} ___
     * @return {?}
     */

  }, {
    key: "addEventListener",
    value: function addEventListener(_, __, ___) {}
    /**
     * @param {?} _
     * @param {?} __
     * @param {?=} ___
     * @return {?}
     */

  }, {
    key: "removeEventListener",
    value: function removeEventListener(_, __, ___) {}
    /**
     * @param {?} _
     * @return {?}
     */

  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(_) {
      return false;
    }
  }]);

  return MockMediaQueryList;
}();
/**
 * Pre-configured provider for MockMatchMedia
 * @type {?}
 */


var MockMatchMediaProvider = {
  // tslint:disable-line:variable-name
  provide: MatchMedia,
  useClass: MockMatchMedia
};
/**
 * @fileoverview added by tsickle
 * Generated from: core/match-media/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: core/media-marshaller/print-hook.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/** @type {?} */

var PRINT = 'print';
/** @type {?} */

var BREAKPOINT_PRINT = {
  alias: PRINT,
  mediaQuery: PRINT,
  priority: 1000
};
/**
 * PrintHook - Use to intercept print MediaQuery activations and force
 *             layouts to render with the specified print alias/breakpoint
 *
 * Used in MediaMarshaller and MediaObserver
 */

var PrintHook = /*#__PURE__*/function () {
  /**
   * @param {?} breakpoints
   * @param {?} layoutConfig
   * @param {?} _document
   */
  function PrintHook(breakpoints, layoutConfig, _document) {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, PrintHook);

    this.breakpoints = breakpoints;
    this.layoutConfig = layoutConfig;
    this._document = _document; // registeredBeforeAfterPrintHooks tracks if we registered the `beforeprint`
    //  and `afterprint` event listeners.

    this.registeredBeforeAfterPrintHooks = false; // isPrintingBeforeAfterEvent is used to track if we are printing from within
    // a `beforeprint` event handler. This prevents the typicall `stopPrinting`
    // form `interceptEvents` so that printing is not stopped while the dialog
    // is still open. This is an extension of the `isPrinting` property on
    // browsers which support `beforeprint` and `afterprint` events.

    this.isPrintingBeforeAfterEvent = false;
    this.beforePrintEventListeners = [];
    this.afterPrintEventListeners = [];
    /**
     * Is this service currently in Print-mode ?
     */

    this.isPrinting = false;
    this.queue = new PrintQueue();
    this.deactivations = [];
  }
  /**
   * Add 'print' mediaQuery: to listen for matchMedia activations
   * @param {?} queries
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(PrintHook, [{
    key: "withPrintQuery",
    value: function withPrintQuery(queries) {
      return [].concat((0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(queries), [PRINT]);
    }
    /**
     * Is the MediaChange event for any 'print' \@media
     * @param {?} e
     * @return {?}
     */

  }, {
    key: "isPrintEvent",
    value: function isPrintEvent(e) {
      return e.mediaQuery.startsWith(PRINT);
    }
    /**
     * What is the desired mqAlias to use while printing?
     * @return {?}
     */

  }, {
    key: "printAlias",
    get: function get() {
      return this.layoutConfig.printWithBreakpoints || [];
    }
    /**
     * Lookup breakpoints associated with print aliases.
     * @return {?}
     */

  }, {
    key: "printBreakPoints",
    get: function get() {
      var _this9 = this;

      return (
        /** @type {?} */
        this.printAlias.map(
        /**
        * @param {?} alias
        * @return {?}
        */
        function (alias) {
          return _this9.breakpoints.findByAlias(alias);
        }).filter(
        /**
        * @param {?} bp
        * @return {?}
        */
        function (bp) {
          return bp !== null;
        })
      );
    }
    /**
     * Lookup breakpoint associated with mediaQuery
     * @param {?} __0
     * @return {?}
     */

  }, {
    key: "getEventBreakpoints",
    value: function getEventBreakpoints(_ref) {
      var mediaQuery = _ref.mediaQuery;

      /** @type {?} */
      var bp = this.breakpoints.findByQuery(mediaQuery);
      /** @type {?} */

      var list = bp ? [].concat((0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this.printBreakPoints), [bp]) : this.printBreakPoints;
      return list.sort(sortDescendingPriority);
    }
    /**
     * Update event with printAlias mediaQuery information
     * @param {?} event
     * @return {?}
     */

  }, {
    key: "updateEvent",
    value: function updateEvent(event) {
      /** @type {?} */
      var bp = this.breakpoints.findByQuery(event.mediaQuery);

      if (this.isPrintEvent(event)) {
        // Reset from 'print' to first (highest priority) print breakpoint
        bp = this.getEventBreakpoints(event)[0];
        event.mediaQuery = bp ? bp.mediaQuery : '';
      }

      return mergeAlias(event, bp);
    } // registerBeforeAfterPrintHooks registers a `beforeprint` event hook so we can
    // trigger print styles synchronously and apply proper layout styles.
    // It is a noop if the hooks have already been registered or if the document's
    // `defaultView` is not available.

    /**
     * @private
     * @param {?} target
     * @return {?}
     */

  }, {
    key: "registerBeforeAfterPrintHooks",
    value: function registerBeforeAfterPrintHooks(target) {
      var _this10 = this;

      // `defaultView` may be null when rendering on the server or in other contexts.
      if (!this._document.defaultView || this.registeredBeforeAfterPrintHooks) {
        return;
      }

      this.registeredBeforeAfterPrintHooks = true;
      /** @type {?} */

      var beforePrintListener =
      /**
      * @return {?}
      */
      function beforePrintListener() {
        // If we aren't already printing, start printing and update the styles as
        // if there was a regular print `MediaChange`(from matchMedia).
        if (!_this10.isPrinting) {
          _this10.isPrintingBeforeAfterEvent = true;

          _this10.startPrinting(target, _this10.getEventBreakpoints(new MediaChange(true, PRINT)));

          target.updateStyles();
        }
      };
      /** @type {?} */


      var afterPrintListener =
      /**
      * @return {?}
      */
      function afterPrintListener() {
        // If we aren't already printing, start printing and update the styles as
        // if there was a regular print `MediaChange`(from matchMedia).
        _this10.isPrintingBeforeAfterEvent = false;

        if (_this10.isPrinting) {
          _this10.stopPrinting(target);

          target.updateStyles();
        }
      }; // Could we have teardown logic to remove if there are no print listeners being used?


      this._document.defaultView.addEventListener('beforeprint', beforePrintListener);

      this._document.defaultView.addEventListener('afterprint', afterPrintListener);

      this.beforePrintEventListeners.push(beforePrintListener);
      this.afterPrintEventListeners.push(afterPrintListener);
    }
    /**
     * Prepare RxJS filter operator with partial application
     * @param {?} target
     * @return {?} pipeable filter predicate
     */

  }, {
    key: "interceptEvents",
    value: function interceptEvents(target) {
      var _this11 = this;

      this.registerBeforeAfterPrintHooks(target);
      return (
        /**
        * @param {?} event
        * @return {?}
        */
        function (event) {
          if (_this11.isPrintEvent(event)) {
            if (event.matches && !_this11.isPrinting) {
              _this11.startPrinting(target, _this11.getEventBreakpoints(event));

              target.updateStyles();
            } else if (!event.matches && _this11.isPrinting && !_this11.isPrintingBeforeAfterEvent) {
              _this11.stopPrinting(target);

              target.updateStyles();
            }
          } else {
            _this11.collectActivations(event);
          }
        }
      );
    }
    /**
     * Stop mediaChange event propagation in event streams
     * @return {?}
     */

  }, {
    key: "blockPropagation",
    value: function blockPropagation() {
      var _this12 = this;

      return (
        /**
        * @param {?} event
        * @return {?}
        */
        function (event) {
          return !(_this12.isPrinting || _this12.isPrintEvent(event));
        }
      );
    }
    /**
     * Save current activateBreakpoints (for later restore)
     * and substitute only the printAlias breakpoint
     * @protected
     * @param {?} target
     * @param {?} bpList
     * @return {?}
     */

  }, {
    key: "startPrinting",
    value: function startPrinting(target, bpList) {
      this.isPrinting = true;
      target.activatedBreakpoints = this.queue.addPrintBreakpoints(bpList);
    }
    /**
     * For any print de-activations, reset the entire print queue
     * @protected
     * @param {?} target
     * @return {?}
     */

  }, {
    key: "stopPrinting",
    value: function stopPrinting(target) {
      target.activatedBreakpoints = this.deactivations;
      this.deactivations = [];
      this.queue.clear();
      this.isPrinting = false;
    }
    /**
     * To restore pre-Print Activations, we must capture the proper
     * list of breakpoint activations BEFORE print starts. OnBeforePrint()
     * is supported; so 'print' mediaQuery activations are used as a fallback
     * in browsers without `beforeprint` support.
     *
     * >  But activated breakpoints are deactivated BEFORE 'print' activation.
     *
     * Let's capture all de-activations using the following logic:
     *
     *  When not printing:
     *    - clear cache when activating non-print breakpoint
     *    - update cache (and sort) when deactivating
     *
     *  When printing:
     *    - sort and save when starting print
     *    - restore as activatedTargets and clear when stop printing
     * @param {?} event
     * @return {?}
     */

  }, {
    key: "collectActivations",
    value: function collectActivations(event) {
      if (!this.isPrinting || this.isPrintingBeforeAfterEvent) {
        if (!event.matches) {
          /** @type {?} */
          var bp = this.breakpoints.findByQuery(event.mediaQuery);

          if (bp) {
            // Deactivating a breakpoint
            this.deactivations.push(bp);
            this.deactivations.sort(sortDescendingPriority);
          }
        } else if (!this.isPrintingBeforeAfterEvent) {
          // Only clear deactivations if we aren't printing from a `beforeprint` event.
          // Otherwise this will clear before `stopPrinting()` is called to restore
          // the pre-Print Activations.
          this.deactivations = [];
        }
      }
    }
    /**
     * Teardown logic for the service.
     * @return {?}
     */

  }, {
    key: "ngOnDestroy",
    value: function ngOnDestroy() {
      var _this13 = this;

      this.beforePrintEventListeners.forEach(
      /**
      * @param {?} l
      * @return {?}
      */
      function (l) {
        return _this13._document.defaultView.removeEventListener('beforeprint', l);
      });
      this.afterPrintEventListeners.forEach(
      /**
      * @param {?} l
      * @return {?}
      */
      function (l) {
        return _this13._document.defaultView.removeEventListener('afterprint', l);
      });
    }
  }]);

  return PrintHook;
}();

PrintHook.ɵfac = function PrintHook_Factory(t) {
  return new (t || PrintHook)(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](BreakPointRegistry), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](LAYOUT_CONFIG), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT));
};
/** @nocollapse */


PrintHook.ctorParameters = function () {
  return [{
    type: BreakPointRegistry
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [LAYOUT_CONFIG]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT]
    }]
  }];
};
/** @nocollapse */


PrintHook.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineInjectable"])({
  factory: function PrintHook_Factory() {
    return new PrintHook((0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(BreakPointRegistry), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(LAYOUT_CONFIG), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT));
  },
  token: PrintHook,
  providedIn: "root"
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵsetClassMetadata"](PrintHook, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: BreakPointRegistry
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [LAYOUT_CONFIG]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT]
      }]
    }];
  }, null);
})(); // ************************************************************************
// Internal Utility class 'PrintQueue'
// ************************************************************************

/**
 * Utility class to manage print breakpoints + activatedBreakpoints
 * with correct sorting WHILE printing
 */


var PrintQueue = /*#__PURE__*/function () {
  function PrintQueue() {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, PrintQueue);

    /**
     * Sorted queue with prioritized print breakpoints
     */
    this.printBreakpoints = [];
  }
  /**
   * @param {?} bpList
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(PrintQueue, [{
    key: "addPrintBreakpoints",
    value: function addPrintBreakpoints(bpList) {
      var _this14 = this;

      bpList.push(BREAKPOINT_PRINT);
      bpList.sort(sortDescendingPriority);
      bpList.forEach(
      /**
      * @param {?} bp
      * @return {?}
      */
      function (bp) {
        return _this14.addBreakpoint(bp);
      });
      return this.printBreakpoints;
    }
    /**
     * Add Print breakpoint to queue
     * @param {?} bp
     * @return {?}
     */

  }, {
    key: "addBreakpoint",
    value: function addBreakpoint(bp) {
      if (!!bp) {
        /** @type {?} */
        var bpInList = this.printBreakpoints.find(
        /**
        * @param {?} it
        * @return {?}
        */
        function (it) {
          return it.mediaQuery === bp.mediaQuery;
        });

        if (bpInList === undefined) {
          // If this is a `printAlias` breakpoint, then append. If a true 'print' breakpoint,
          // register as highest priority in the queue
          this.printBreakpoints = isPrintBreakPoint(bp) ? [bp].concat((0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this.printBreakpoints)) : [].concat((0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this.printBreakpoints), [bp]);
        }
      }
    }
    /**
     * Restore original activated breakpoints and clear internal caches
     * @return {?}
     */

  }, {
    key: "clear",
    value: function clear() {
      this.printBreakpoints = [];
    }
  }]);

  return PrintQueue;
}(); // ************************************************************************
// Internal Utility methods
// ************************************************************************

/**
 * Only support intercept queueing if the Breakpoint is a print \@media query
 * @param {?} bp
 * @return {?}
 */


function isPrintBreakPoint(bp) {
  return bp ? bp.mediaQuery.startsWith(PRINT) : false;
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/utils/array.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * Wraps the provided value in an array, unless the provided value is an array.
 * @template T
 * @param {?} value
 * @return {?}
 */


function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/media-observer/media-observer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * MediaObserver enables applications to listen for 1..n mediaQuery activations and to determine
 * if a mediaQuery is currently activated.
 *
 * Since a breakpoint change will first deactivate 1...n mediaQueries and then possibly activate
 * 1..n mediaQueries, the MediaObserver will debounce notifications and report ALL *activations*
 * in 1 event notification. The reported activations will be sorted in descending priority order.
 *
 * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange
 * notification. For custom mediaQuery notifications, alias information will not be injected and
 * those fields will be ''.
 *
 * Note: Developers should note that only mediaChange activations (not de-activations)
 *       are announced by the MediaObserver.
 *
 * \@usage
 *
 *  // RxJS
 *  import { filter } from 'rxjs/operators';
 *  import { MediaObserver } from '\@angular/flex-layout';
 *
 * \@Component({ ... })
 *  export class AppComponent {
 *    status: string = '';
 *
 *    constructor(mediaObserver: MediaObserver) {
 *      const media$ = mediaObserver.asObservable().pipe(
 *        filter((changes: MediaChange[]) => true)   // silly noop filter
 *      );
 *
 *      media$.subscribe((changes: MediaChange[]) => {
 *        let status = '';
 *        changes.forEach( change => {
 *          status += `'${change.mqAlias}' = (${change.mediaQuery}) <br/>` ;
 *        });
 *        this.status = status;
 *     });
 *
 *    }
 *  }
 */


var MediaObserver = /*#__PURE__*/function () {
  /**
   * @param {?} breakpoints
   * @param {?} matchMedia
   * @param {?} hook
   */
  function MediaObserver(breakpoints, matchMedia, hook) {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, MediaObserver);

    this.breakpoints = breakpoints;
    this.matchMedia = matchMedia;
    this.hook = hook;
    /**
     * Filter MediaChange notifications for overlapping breakpoints
     */

    this.filterOverlaps = false;
    this.destroyed$ = new rxjs__WEBPACK_IMPORTED_MODULE_9__.Subject();
    this._media$ = this.watchActivations();
    this.media$ = this._media$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(
    /**
    * @param {?} changes
    * @return {?}
    */
    function (changes) {
      return changes.length > 0;
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.map)(
    /**
    * @param {?} changes
    * @return {?}
    */
    function (changes) {
      return changes[0];
    }));
  }
  /**
   * Completes the active subject, signalling to all complete for all
   * MediaObserver subscribers
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(MediaObserver, [{
    key: "ngOnDestroy",
    value: function ngOnDestroy() {
      this.destroyed$.next();
      this.destroyed$.complete();
    } // ************************************************
    // Public Methods
    // ************************************************

    /**
     * Observe changes to current activation 'list'
     * @return {?}
     */

  }, {
    key: "asObservable",
    value: function asObservable() {
      return this._media$;
    }
    /**
     * Allow programmatic query to determine if one or more media query/alias match
     * the current viewport size.
     * @param {?} value One or more media queries (or aliases) to check.
     * @return {?} Whether any of the media queries match.
     */

  }, {
    key: "isActive",
    value: function isActive(value) {
      var _this15 = this;

      /** @type {?} */
      var aliases = splitQueries(coerceArray(value));
      return aliases.some(
      /**
      * @param {?} alias
      * @return {?}
      */
      function (alias) {
        /** @type {?} */
        var query = toMediaQuery(alias, _this15.breakpoints);
        return query !== null && _this15.matchMedia.isActive(query);
      });
    } // ************************************************
    // Internal Methods
    // ************************************************

    /**
     * Register all the mediaQueries registered in the BreakPointRegistry
     * This is needed so subscribers can be auto-notified of all standard, registered
     * mediaQuery activations
     * @private
     * @return {?}
     */

  }, {
    key: "watchActivations",
    value: function watchActivations() {
      /** @type {?} */
      var queries = this.breakpoints.items.map(
      /**
      * @param {?} bp
      * @return {?}
      */
      function (bp) {
        return bp.mediaQuery;
      });
      return this.buildObservable(queries);
    }
    /**
     * Only pass/announce activations (not de-activations)
     *
     * Since multiple-mediaQueries can be activation in a cycle,
     * gather all current activations into a single list of changes to observers
     *
     * Inject associated (if any) alias information into the MediaChange event
     * - Exclude mediaQuery activations for overlapping mQs. List bounded mQ ranges only
     * - Exclude print activations that do not have an associated mediaQuery
     *
     * NOTE: the raw MediaChange events [from MatchMedia] do not
     *       contain important alias information; as such this info
     *       must be injected into the MediaChange
     * @private
     * @param {?} mqList
     * @return {?}
     */

  }, {
    key: "buildObservable",
    value: function buildObservable(mqList) {
      var _this16 = this;

      /** @type {?} */
      var hasChanges =
      /**
      * @param {?} changes
      * @return {?}
      */
      function hasChanges(changes) {
        /** @type {?} */
        var isValidQuery =
        /**
        * @param {?} change
        * @return {?}
        */
        function isValidQuery(change) {
          return change.mediaQuery.length > 0;
        };

        return changes.filter(isValidQuery).length > 0;
      };
      /** @type {?} */


      var excludeOverlaps =
      /**
      * @param {?} changes
      * @return {?}
      */
      function excludeOverlaps(changes) {
        return !_this16.filterOverlaps ? changes : changes.filter(
        /**
        * @param {?} change
        * @return {?}
        */
        function (change) {
          /** @type {?} */
          var bp = _this16.breakpoints.findByQuery(change.mediaQuery);

          return !bp ? true : !bp.overlapping;
        });
      };
      /**
       */


      return this.matchMedia.observe(this.hook.withPrintQuery(mqList)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(
      /**
      * @param {?} change
      * @return {?}
      */
      function (change) {
        return change.matches;
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_15__.debounceTime)(0, rxjs__WEBPACK_IMPORTED_MODULE_16__.asapScheduler), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_17__.switchMap)(
      /**
      * @param {?} _
      * @return {?}
      */
      function (_) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_18__.of)(_this16.findAllActivations());
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.map)(excludeOverlaps), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(hasChanges), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.takeUntil)(this.destroyed$));
    }
    /**
     * Find all current activations and prepare single list of activations
     * sorted by descending priority.
     * @private
     * @return {?}
     */

  }, {
    key: "findAllActivations",
    value: function findAllActivations() {
      var _this17 = this;

      /** @type {?} */
      var mergeMQAlias =
      /**
      * @param {?} change
      * @return {?}
      */
      function mergeMQAlias(change) {
        /** @type {?} */
        var bp = _this17.breakpoints.findByQuery(change.mediaQuery);

        return mergeAlias(change, bp);
      };
      /** @type {?} */


      var replaceWithPrintAlias =
      /**
      * @param {?} change
      * @return {?}
      */
      function replaceWithPrintAlias(change) {
        return _this17.hook.isPrintEvent(change) ? _this17.hook.updateEvent(change) : change;
      };

      return this.matchMedia.activations.map(
      /**
      * @param {?} query
      * @return {?}
      */
      function (query) {
        return new MediaChange(true, query);
      }).map(replaceWithPrintAlias).map(mergeMQAlias).sort(sortDescendingPriority);
    }
  }]);

  return MediaObserver;
}();

MediaObserver.ɵfac = function MediaObserver_Factory(t) {
  return new (t || MediaObserver)(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](BreakPointRegistry), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](MatchMedia), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](PrintHook));
};
/** @nocollapse */


MediaObserver.ctorParameters = function () {
  return [{
    type: BreakPointRegistry
  }, {
    type: MatchMedia
  }, {
    type: PrintHook
  }];
};
/** @nocollapse */


MediaObserver.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineInjectable"])({
  factory: function MediaObserver_Factory() {
    return new MediaObserver((0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(BreakPointRegistry), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(MatchMedia), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(PrintHook));
  },
  token: MediaObserver,
  providedIn: "root"
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵsetClassMetadata"](MediaObserver, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: BreakPointRegistry
    }, {
      type: MatchMedia
    }, {
      type: PrintHook
    }];
  }, null);
})();
/**
 * Find associated breakpoint (if any)
 * @param {?} query
 * @param {?} locator
 * @return {?}
 */


function toMediaQuery(query, locator) {
  /** @type {?} */
  var bp = locator.findByAlias(query) || locator.findByQuery(query);
  return bp ? bp.mediaQuery : null;
}
/**
 * Split each query string into separate query strings if two queries are provided as comma
 * separated.
 * @param {?} queries
 * @return {?}
 */


function splitQueries(queries) {
  return queries.map(
  /**
  * @param {?} query
  * @return {?}
  */
  function (query) {
    return query.split(',');
  }).reduce(
  /**
  * @param {?} a1
  * @param {?} a2
  * @return {?}
  */
  function (a1, a2) {
    return a1.concat(a2);
  }).map(
  /**
  * @param {?} query
  * @return {?}
  */
  function (query) {
    return query.trim();
  });
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/media-observer/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: core/media-trigger/media-trigger.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * Class
 */


var MediaTrigger = /*#__PURE__*/function () {
  /**
   * @param {?} breakpoints
   * @param {?} matchMedia
   * @param {?} layoutConfig
   * @param {?} _platformId
   * @param {?} _document
   */
  function MediaTrigger(breakpoints, matchMedia, layoutConfig, _platformId, _document) {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, MediaTrigger);

    this.breakpoints = breakpoints;
    this.matchMedia = matchMedia;
    this.layoutConfig = layoutConfig;
    this._platformId = _platformId;
    this._document = _document;
    this.hasCachedRegistryMatches = false;
    this.originalActivations = [];
    this.originalRegistry = new Map();
  }
  /**
   * Manually activate range of breakpoints
   * @param {?} list array of mediaQuery or alias strings
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(MediaTrigger, [{
    key: "activate",
    value: function activate(list) {
      list = list.map(
      /**
      * @param {?} it
      * @return {?}
      */
      function (it) {
        return it.trim();
      }); // trim queries

      this.saveActivations();
      this.deactivateAll();
      this.setActivations(list);
      this.prepareAutoRestore();
    }
    /**
     * Restore original, 'real' breakpoints and emit events
     * to trigger stream notification
     * @return {?}
     */

  }, {
    key: "restore",
    value: function restore() {
      if (this.hasCachedRegistryMatches) {
        /** @type {?} */
        var extractQuery =
        /**
        * @param {?} change
        * @return {?}
        */
        function extractQuery(change) {
          return change.mediaQuery;
        };
        /** @type {?} */


        var list = this.originalActivations.map(extractQuery);

        try {
          this.deactivateAll();
          this.restoreRegistryMatches();
          this.setActivations(list);
        } finally {
          this.originalActivations = [];

          if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
          }
        }
      }
    } // ************************************************
    // Internal Methods
    // ************************************************

    /**
     * Whenever window resizes, immediately auto-restore original
     * activations (if we are simulating activations)
     * @private
     * @return {?}
     */

  }, {
    key: "prepareAutoRestore",
    value: function prepareAutoRestore() {
      /** @type {?} */
      var isBrowser = (0,_angular_common__WEBPACK_IMPORTED_MODULE_7__.isPlatformBrowser)(this._platformId) && this._document;
      /** @type {?} */


      var enableAutoRestore = isBrowser && this.layoutConfig.mediaTriggerAutoRestore;

      if (enableAutoRestore) {
        /** @type {?} */
        var resize$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_20__.fromEvent)(window, 'resize').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.take)(1));
        this.resizeSubscription = resize$.subscribe(this.restore.bind(this));
      }
    }
    /**
     * Notify all matchMedia subscribers of de-activations
     *
     * Note: we must force 'matches' updates for
     *       future matchMedia::activation lookups
     * @private
     * @return {?}
     */

  }, {
    key: "deactivateAll",
    value: function deactivateAll() {
      /** @type {?} */
      var list = this.currentActivations;
      this.forceRegistryMatches(list, false);
      this.simulateMediaChanges(list, false);
    }
    /**
     * Cache current activations as sorted, prioritized list of MediaChanges
     * @private
     * @return {?}
     */

  }, {
    key: "saveActivations",
    value: function saveActivations() {
      var _this18 = this;

      if (!this.hasCachedRegistryMatches) {
        /** @type {?} */
        var toMediaChange =
        /**
        * @param {?} query
        * @return {?}
        */
        function toMediaChange(query) {
          return new MediaChange(true, query);
        };
        /** @type {?} */


        var mergeMQAlias =
        /**
        * @param {?} change
        * @return {?}
        */
        function mergeMQAlias(change) {
          /** @type {?} */
          var bp = _this18.breakpoints.findByQuery(change.mediaQuery);

          return mergeAlias(change, bp);
        };

        this.originalActivations = this.currentActivations.map(toMediaChange).map(mergeMQAlias).sort(sortDescendingPriority);
        this.cacheRegistryMatches();
      }
    }
    /**
     * Force set manual activations for specified mediaQuery list
     * @private
     * @param {?} list
     * @return {?}
     */

  }, {
    key: "setActivations",
    value: function setActivations(list) {
      if (!!this.originalRegistry) {
        this.forceRegistryMatches(list, true);
      }

      this.simulateMediaChanges(list);
    }
    /**
     * For specified mediaQuery list manually simulate activations or deactivations
     * @private
     * @param {?} queries
     * @param {?=} matches
     * @return {?}
     */

  }, {
    key: "simulateMediaChanges",
    value: function simulateMediaChanges(queries) {
      var _this19 = this;

      var matches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      /** @type {?} */
      var toMediaQuery =
      /**
      * @param {?} query
      * @return {?}
      */
      function toMediaQuery(query) {
        /** @type {?} */
        var locator = _this19.breakpoints;
        /** @type {?} */

        var bp = locator.findByAlias(query) || locator.findByQuery(query);
        return bp ? bp.mediaQuery : query;
      };
      /** @type {?} */


      var emitChangeEvent =
      /**
      * @param {?} query
      * @return {?}
      */
      function emitChangeEvent(query) {
        return _this19.emitChangeEvent(matches, query);
      };

      queries.map(toMediaQuery).forEach(emitChangeEvent);
    }
    /**
     * Replace current registry with simulated registry...
     * Note: this is required since MediaQueryList::matches is 'readOnly'
     * @private
     * @param {?} queries
     * @param {?} matches
     * @return {?}
     */

  }, {
    key: "forceRegistryMatches",
    value: function forceRegistryMatches(queries, matches) {
      /** @type {?} */
      var registry = new Map();
      queries.forEach(
      /**
      * @param {?} query
      * @return {?}
      */
      function (query) {
        registry.set(query,
        /** @type {?} */
        {
          matches: matches
        });
      });
      this.matchMedia.registry = registry;
    }
    /**
     * Save current MatchMedia::registry items.
     * @private
     * @return {?}
     */

  }, {
    key: "cacheRegistryMatches",
    value: function cacheRegistryMatches() {
      /** @type {?} */
      var target = this.originalRegistry;
      target.clear();
      this.matchMedia.registry.forEach(
      /**
      * @param {?} value
      * @param {?} key
      * @return {?}
      */
      function (value, key) {
        target.set(key, value);
      });
      this.hasCachedRegistryMatches = true;
    }
    /**
     * Restore original, 'true' registry
     * @private
     * @return {?}
     */

  }, {
    key: "restoreRegistryMatches",
    value: function restoreRegistryMatches() {
      /** @type {?} */
      var target = this.matchMedia.registry;
      target.clear();
      this.originalRegistry.forEach(
      /**
      * @param {?} value
      * @param {?} key
      * @return {?}
      */
      function (value, key) {
        target.set(key, value);
      });
      this.originalRegistry.clear();
      this.hasCachedRegistryMatches = false;
    }
    /**
     * Manually emit a MediaChange event via the MatchMedia to MediaMarshaller and MediaObserver
     * @private
     * @param {?} matches
     * @param {?} query
     * @return {?}
     */

  }, {
    key: "emitChangeEvent",
    value: function emitChangeEvent(matches, query) {
      this.matchMedia.source.next(new MediaChange(matches, query));
    }
    /**
     * @private
     * @return {?}
     */

  }, {
    key: "currentActivations",
    get: function get() {
      return this.matchMedia.activations;
    }
  }]);

  return MediaTrigger;
}();

MediaTrigger.ɵfac = function MediaTrigger_Factory(t) {
  return new (t || MediaTrigger)(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](BreakPointRegistry), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](MatchMedia), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](LAYOUT_CONFIG), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT));
};
/** @nocollapse */


MediaTrigger.ctorParameters = function () {
  return [{
    type: BreakPointRegistry
  }, {
    type: MatchMedia
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [LAYOUT_CONFIG]
    }]
  }, {
    type: Object,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT]
    }]
  }];
};
/** @nocollapse */


MediaTrigger.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineInjectable"])({
  factory: function MediaTrigger_Factory() {
    return new MediaTrigger((0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(BreakPointRegistry), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(MatchMedia), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(LAYOUT_CONFIG), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT));
  },
  token: MediaTrigger,
  providedIn: "root"
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵsetClassMetadata"](MediaTrigger, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: BreakPointRegistry
    }, {
      type: MatchMedia
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [LAYOUT_CONFIG]
      }]
    }, {
      type: Object,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [_angular_common__WEBPACK_IMPORTED_MODULE_7__.DOCUMENT]
      }]
    }];
  }, null);
})();
/**
 * @fileoverview added by tsickle
 * Generated from: core/media-trigger/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: core/utils/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: utils/auto-prefixer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * Applies CSS prefixes to appropriate style keys.
 *
 * Note: `-ms-`, `-moz` and `-webkit-box` are no longer supported. e.g.
 *    {
 *      display: -webkit-flex;     NEW - Safari 6.1+. iOS 7.1+, BB10
 *      display: flex;             NEW, Spec - Firefox, Chrome, Opera
 *      // display: -webkit-box;   OLD - iOS 6-, Safari 3.1-6, BB7
 *      // display: -ms-flexbox;   TWEENER - IE 10
 *      // display: -moz-flexbox;  OLD - Firefox
 *    }
 * @param {?} target
 * @return {?}
 */


function applyCssPrefixes(target) {
  for (var key in target) {
    /** @type {?} */
    var value = target[key] || '';

    switch (key) {
      case 'display':
        if (value === 'flex') {
          target['display'] = ['-webkit-flex', 'flex'];
        } else if (value === 'inline-flex') {
          target['display'] = ['-webkit-inline-flex', 'inline-flex'];
        } else {
          target['display'] = value;
        }

        break;

      case 'align-items':
      case 'align-self':
      case 'align-content':
      case 'flex':
      case 'flex-basis':
      case 'flex-flow':
      case 'flex-grow':
      case 'flex-shrink':
      case 'flex-wrap':
      case 'justify-content':
        target['-webkit-' + key] = value;
        break;

      case 'flex-direction':
        value = value || 'row';
        target['-webkit-flex-direction'] = value;
        target['flex-direction'] = value;
        break;

      case 'order':
        target['order'] = target['-webkit-' + key] = isNaN(+value) ? '0' : value;
        break;
    }
  }

  return target;
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/style-utils/style-utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */


var StyleUtils = /*#__PURE__*/function () {
  /**
   * @param {?} _serverStylesheet
   * @param {?} _serverModuleLoaded
   * @param {?} _platformId
   * @param {?} layoutConfig
   */
  function StyleUtils(_serverStylesheet, _serverModuleLoaded, _platformId, layoutConfig) {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, StyleUtils);

    this._serverStylesheet = _serverStylesheet;
    this._serverModuleLoaded = _serverModuleLoaded;
    this._platformId = _platformId;
    this.layoutConfig = layoutConfig;
  }
  /**
   * Applies styles given via string pair or object map to the directive element
   * @param {?} element
   * @param {?} style
   * @param {?=} value
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(StyleUtils, [{
    key: "applyStyleToElement",
    value: function applyStyleToElement(element, style) {
      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      /** @type {?} */
      var styles = {};

      if (typeof style === 'string') {
        styles[style] = value;
        style = styles;
      }

      styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);

      this._applyMultiValueStyleToElement(styles, element);
    }
    /**
     * Applies styles given via string pair or object map to the directive's element
     * @param {?} style
     * @param {?=} elements
     * @return {?}
     */

  }, {
    key: "applyStyleToElements",
    value: function applyStyleToElements(style) {
      var _this20 = this;

      var elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      /** @type {?} */
      var styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);
      elements.forEach(
      /**
      * @param {?} el
      * @return {?}
      */
      function (el) {
        _this20._applyMultiValueStyleToElement(styles, el);
      });
    }
    /**
     * Determine the DOM element's Flexbox flow (flex-direction)
     *
     * Check inline style first then check computed (stylesheet) style
     * @param {?} target
     * @return {?}
     */

  }, {
    key: "getFlowDirection",
    value: function getFlowDirection(target) {
      /** @type {?} */
      var query = 'flex-direction';
      /** @type {?} */

      var value = this.lookupStyle(target, query);
      /** @type {?} */

      var hasInlineValue = this.lookupInlineStyle(target, query) || (0,_angular_common__WEBPACK_IMPORTED_MODULE_7__.isPlatformServer)(this._platformId) && this._serverModuleLoaded ? value : '';
      return [value || 'row', hasInlineValue];
    }
    /**
     * @param {?} target
     * @return {?}
     */

  }, {
    key: "hasWrap",
    value: function hasWrap(target) {
      /** @type {?} */
      var query = 'flex-wrap';
      return this.lookupStyle(target, query) === 'wrap';
    }
    /**
     * Find the DOM element's raw attribute value (if any)
     * @param {?} element
     * @param {?} attribute
     * @return {?}
     */

  }, {
    key: "lookupAttributeValue",
    value: function lookupAttributeValue(element, attribute) {
      return element.getAttribute(attribute) || '';
    }
    /**
     * Find the DOM element's inline style value (if any)
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */

  }, {
    key: "lookupInlineStyle",
    value: function lookupInlineStyle(element, styleName) {
      return (0,_angular_common__WEBPACK_IMPORTED_MODULE_7__.isPlatformBrowser)(this._platformId) ? element.style.getPropertyValue(styleName) : this._getServerStyle(element, styleName);
    }
    /**
     * Determine the inline or inherited CSS style
     * NOTE: platform-server has no implementation for getComputedStyle
     * @param {?} element
     * @param {?} styleName
     * @param {?=} inlineOnly
     * @return {?}
     */

  }, {
    key: "lookupStyle",
    value: function lookupStyle(element, styleName) {
      var inlineOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      /** @type {?} */
      var value = '';

      if (element) {
        /** @type {?} */
        var immediateValue = value = this.lookupInlineStyle(element, styleName);

        if (!immediateValue) {
          if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_7__.isPlatformBrowser)(this._platformId)) {
            if (!inlineOnly) {
              value = getComputedStyle(element).getPropertyValue(styleName);
            }
          } else {
            if (this._serverModuleLoaded) {
              value = this._serverStylesheet.getStyleForElement(element, styleName);
            }
          }
        }
      } // Note: 'inline' is the default of all elements, unless UA stylesheet overrides;
      //       in which case getComputedStyle() should determine a valid value.


      return value ? value.trim() : '';
    }
    /**
     * Applies the styles to the element. The styles object map may contain an array of values
     * Each value will be added as element style
     * Keys are sorted to add prefixed styles (like -webkit-x) first, before the standard ones
     * @private
     * @param {?} styles
     * @param {?} element
     * @return {?}
     */

  }, {
    key: "_applyMultiValueStyleToElement",
    value: function _applyMultiValueStyleToElement(styles, element) {
      var _this21 = this;

      Object.keys(styles).sort().forEach(
      /**
      * @param {?} key
      * @return {?}
      */
      function (key) {
        /** @type {?} */
        var el = styles[key];
        /** @type {?} */

        var values = Array.isArray(el) ? el : [el];
        values.sort();

        var _iterator = (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_0__["default"])(values),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var value = _step.value;
            value = value ? value + '' : '';

            if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_7__.isPlatformBrowser)(_this21._platformId) || !_this21._serverModuleLoaded) {
              (0,_angular_common__WEBPACK_IMPORTED_MODULE_7__.isPlatformBrowser)(_this21._platformId) ? element.style.setProperty(key, value) : _this21._setServerStyle(element, key, value);
            } else {
              _this21._serverStylesheet.addStyleToElement(element, key, value);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }
    /**
     * @private
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */

  }, {
    key: "_setServerStyle",
    value: function _setServerStyle(element, styleName, styleValue) {
      styleName = styleName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
      /** @type {?} */

      var styleMap = this._readStyleAttribute(element);

      styleMap[styleName] = styleValue || '';

      this._writeStyleAttribute(element, styleMap);
    }
    /**
     * @private
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */

  }, {
    key: "_getServerStyle",
    value: function _getServerStyle(element, styleName) {
      /** @type {?} */
      var styleMap = this._readStyleAttribute(element);

      return styleMap[styleName] || '';
    }
    /**
     * @private
     * @param {?} element
     * @return {?}
     */

  }, {
    key: "_readStyleAttribute",
    value: function _readStyleAttribute(element) {
      /** @type {?} */
      var styleMap = {};
      /** @type {?} */

      var styleAttribute = element.getAttribute('style');

      if (styleAttribute) {
        /** @type {?} */
        var styleList = styleAttribute.split(/;+/g);

        for (var i = 0; i < styleList.length; i++) {
          /** @type {?} */
          var style = styleList[i].trim();

          if (style.length > 0) {
            /** @type {?} */
            var colonIndex = style.indexOf(':');

            if (colonIndex === -1) {
              throw new Error("Invalid CSS style: ".concat(style));
            }
            /** @type {?} */


            var name = style.substr(0, colonIndex).trim();
            styleMap[name] = style.substr(colonIndex + 1).trim();
          }
        }
      }

      return styleMap;
    }
    /**
     * @private
     * @param {?} element
     * @param {?} styleMap
     * @return {?}
     */

  }, {
    key: "_writeStyleAttribute",
    value: function _writeStyleAttribute(element, styleMap) {
      /** @type {?} */
      var styleAttrValue = '';

      for (var key in styleMap) {
        /** @type {?} */
        var newValue = styleMap[key];

        if (newValue) {
          styleAttrValue += key + ':' + styleMap[key] + ';';
        }
      }

      element.setAttribute('style', styleAttrValue);
    }
  }]);

  return StyleUtils;
}();

StyleUtils.ɵfac = function StyleUtils_Factory(t) {
  return new (t || StyleUtils)(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](StylesheetMap), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](SERVER_TOKEN), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](LAYOUT_CONFIG));
};
/** @nocollapse */


StyleUtils.ctorParameters = function () {
  return [{
    type: StylesheetMap
  }, {
    type: Boolean,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [SERVER_TOKEN]
    }]
  }, {
    type: Object,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID]
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
      args: [LAYOUT_CONFIG]
    }]
  }];
};
/** @nocollapse */


StyleUtils.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineInjectable"])({
  factory: function StyleUtils_Factory() {
    return new StyleUtils((0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(StylesheetMap), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(SERVER_TOKEN), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(LAYOUT_CONFIG));
  },
  token: StyleUtils,
  providedIn: "root"
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵsetClassMetadata"](StyleUtils, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: StylesheetMap
    }, {
      type: Boolean,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [SERVER_TOKEN]
      }]
    }, {
      type: Object,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_8__.PLATFORM_ID]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject,
        args: [LAYOUT_CONFIG]
      }]
    }];
  }, null);
})();
/**
 * @fileoverview added by tsickle
 * Generated from: core/style-builder/style-builder.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * A class that encapsulates CSS style generation for common directives
 * @abstract
 */


var StyleBuilder = /*#__PURE__*/function () {
  function StyleBuilder() {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, StyleBuilder);

    /**
     * Whether to cache the generated output styles
     */
    this.shouldCache = true;
  }
  /**
   * Run a side effect computation given the input string and the computed styles
   * from the build task and the host configuration object
   * NOTE: This should be a no-op unless an algorithm is provided in a subclass
   * @param {?} _input
   * @param {?} _styles
   * @param {?=} _parent
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(StyleBuilder, [{
    key: "sideEffect",
    value: function sideEffect(_input, _styles, _parent) {}
  }]);

  return StyleBuilder;
}();
/**
 * @fileoverview added by tsickle
 * Generated from: core/basis-validator/basis-validator.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * The flex API permits 3 or 1 parts of the value:
 *    - `flex-grow flex-shrink flex-basis`, or
 *    - `flex-basis`
 * @param {?} basis
 * @param {?=} grow
 * @param {?=} shrink
 * @return {?}
 */


function validateBasis(basis) {
  var grow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '1';
  var shrink = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '1';

  /** @type {?} */
  var parts = [grow, shrink, basis];
  /** @type {?} */

  var j = basis.indexOf('calc');

  if (j > 0) {
    parts[2] = _validateCalcValue(basis.substring(j).trim());
    /** @type {?} */

    var matches = basis.substr(0, j).trim().split(' ');

    if (matches.length == 2) {
      parts[0] = matches[0];
      parts[1] = matches[1];
    }
  } else if (j == 0) {
    parts[2] = _validateCalcValue(basis.trim());
  } else {
    /** @type {?} */
    var _matches = basis.split(' ');

    parts = _matches.length === 3 ? _matches : [grow, shrink, basis];
  }

  return parts;
}
/**
 * Calc expressions require whitespace before & after any expression operators
 * This is a simple, crude whitespace padding solution.
 *   - '3 3 calc(15em + 20px)'
 *   - calc(100% / 7 * 2)
 *   - 'calc(15em + 20px)'
 *   - 'calc(15em+20px)'
 *   - '37px'
 *   = '43%'
 * @param {?} calc
 * @return {?}
 */


function _validateCalcValue(calc) {
  return calc.replace(/[\s]/g, '').replace(/[\/\*\+\-]/g, ' $& ');
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/media-marshaller/media-marshaller.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * MediaMarshaller - register responsive values from directives and
 *                   trigger them based on media query events
 */


var MediaMarshaller = /*#__PURE__*/function () {
  /**
   * @param {?} matchMedia
   * @param {?} breakpoints
   * @param {?} hook
   */
  function MediaMarshaller(matchMedia, breakpoints, hook) {
    (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_6__["default"])(this, MediaMarshaller);

    this.matchMedia = matchMedia;
    this.breakpoints = breakpoints;
    this.hook = hook;
    this.activatedBreakpoints = [];
    this.elementMap = new Map();
    this.elementKeyMap = new WeakMap();
    this.watcherMap = new WeakMap(); // special triggers to update elements
    // special triggers to update elements

    this.updateMap = new WeakMap(); // callback functions to update styles
    // callback functions to update styles

    this.clearMap = new WeakMap(); // callback functions to clear styles
    // callback functions to clear styles

    this.subject = new rxjs__WEBPACK_IMPORTED_MODULE_9__.Subject();
    this.observeActivations();
  }
  /**
   * @return {?}
   */


  (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__["default"])(MediaMarshaller, [{
    key: "activatedAlias",
    get: function get() {
      return this.activatedBreakpoints[0] ? this.activatedBreakpoints[0].alias : '';
    }
    /**
     * Update styles on breakpoint activates or deactivates
     * @param {?} mc
     * @return {?}
     */

  }, {
    key: "onMediaChange",
    value: function onMediaChange(mc) {
      /** @type {?} */
      var bp = this.findByQuery(mc.mediaQuery);

      if (bp) {
        mc = mergeAlias(mc, bp);

        if (mc.matches && this.activatedBreakpoints.indexOf(bp) === -1) {
          this.activatedBreakpoints.push(bp);
          this.activatedBreakpoints.sort(sortDescendingPriority);
          this.updateStyles();
        } else if (!mc.matches && this.activatedBreakpoints.indexOf(bp) !== -1) {
          // Remove the breakpoint when it's deactivated
          this.activatedBreakpoints.splice(this.activatedBreakpoints.indexOf(bp), 1);
          this.activatedBreakpoints.sort(sortDescendingPriority);
          this.updateStyles();
        }
      }
    }
    /**
     * initialize the marshaller with necessary elements for delegation on an element
     * @param {?} element
     * @param {?} key
     * @param {?=} updateFn optional callback so that custom bp directives don't have to re-provide this
     * @param {?=} clearFn optional callback so that custom bp directives don't have to re-provide this
     * @param {?=} extraTriggers other triggers to force style updates (e.g. layout, directionality, etc)
     * @return {?}
     */

  }, {
    key: "init",
    value: function init(element, key, updateFn, clearFn) {
      var extraTriggers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
      initBuilderMap(this.updateMap, element, key, updateFn);
      initBuilderMap(this.clearMap, element, key, clearFn);
      this.buildElementKeyMap(element, key);
      this.watchExtraTriggers(element, key, extraTriggers);
    }
    /**
     * get the value for an element and key and optionally a given breakpoint
     * @param {?} element
     * @param {?} key
     * @param {?=} bp
     * @return {?}
     */

  }, {
    key: "getValue",
    value: function getValue(element, key, bp) {
      /** @type {?} */
      var bpMap = this.elementMap.get(element);

      if (bpMap) {
        /** @type {?} */
        var values = bp !== undefined ? bpMap.get(bp) : this.getActivatedValues(bpMap, key);

        if (values) {
          return values.get(key);
        }
      }

      return undefined;
    }
    /**
     * whether the element has values for a given key
     * @param {?} element
     * @param {?} key
     * @return {?}
     */

  }, {
    key: "hasValue",
    value: function hasValue(element, key) {
      /** @type {?} */
      var bpMap = this.elementMap.get(element);

      if (bpMap) {
        /** @type {?} */
        var values = this.getActivatedValues(bpMap, key);

        if (values) {
          return values.get(key) !== undefined || false;
        }
      }

      return false;
    }
    /**
     * Set the value for an input on a directive
     * @param {?} element the element in question
     * @param {?} key the type of the directive (e.g. flex, layout-gap, etc)
     * @param {?} val the value for the breakpoint
     * @param {?} bp the breakpoint suffix (empty string = default)
     * @return {?}
     */

  }, {
    key: "setValue",
    value: function setValue(element, key, val, bp) {
      /** @type {?} */
      var bpMap = this.elementMap.get(element);

      if (!bpMap) {
        bpMap = new Map().set(bp, new Map().set(key, val));
        this.elementMap.set(element, bpMap);
      } else {
        /** @type {?} */
        var values = (bpMap.get(bp) || new Map()).set(key, val);
        bpMap.set(bp, values);
        this.elementMap.set(element, bpMap);
      }
      /** @type {?} */


      var value = this.getValue(element, key);

      if (value !== undefined) {
        this.updateElement(element, key, value);
      }
    }
    /**
     * Track element value changes for a specific key
     * @param {?} element
     * @param {?} key
     * @return {?}
     */

  }, {
    key: "trackValue",
    value: function trackValue(element, key) {
      return this.subject.asObservable().pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(
      /**
      * @param {?} v
      * @return {?}
      */
      function (v) {
        return v.element === element && v.key === key;
      }));
    }
    /**
     * update all styles for all elements on the current breakpoint
     * @return {?}
     */

  }, {
    key: "updateStyles",
    value: function updateStyles() {
      var _this22 = this;

      this.elementMap.forEach(
      /**
      * @param {?} bpMap
      * @param {?} el
      * @return {?}
      */
      function (bpMap, el) {
        /** @type {?} */
        var keyMap = new Set(
        /** @type {?} */
        _this22.elementKeyMap.get(el));
        /** @type {?} */

        var valueMap = _this22.getActivatedValues(bpMap);

        if (valueMap) {
          valueMap.forEach(
          /**
          * @param {?} v
          * @param {?} k
          * @return {?}
          */
          function (v, k) {
            _this22.updateElement(el, k, v);

            keyMap.delete(k);
          });
        }

        keyMap.forEach(
        /**
        * @param {?} k
        * @return {?}
        */
        function (k) {
          valueMap = _this22.getActivatedValues(bpMap, k);

          if (valueMap) {
            /** @type {?} */
            var value = valueMap.get(k);

            _this22.updateElement(el, k, value);
          } else {
            _this22.clearElement(el, k);
          }
        });
      });
    }
    /**
     * clear the styles for a given element
     * @param {?} element
     * @param {?} key
     * @return {?}
     */

  }, {
    key: "clearElement",
    value: function clearElement(element, key) {
      /** @type {?} */
      var builders = this.clearMap.get(element);

      if (builders) {
        /** @type {?} */
        var clearFn =
        /** @type {?} */
        builders.get(key);

        if (!!clearFn) {
          clearFn();
          this.subject.next({
            element: element,
            key: key,
            value: ''
          });
        }
      }
    }
    /**
     * update a given element with the activated values for a given key
     * @param {?} element
     * @param {?} key
     * @param {?} value
     * @return {?}
     */

  }, {
    key: "updateElement",
    value: function updateElement(element, key, value) {
      /** @type {?} */
      var builders = this.updateMap.get(element);

      if (builders) {
        /** @type {?} */
        var updateFn =
        /** @type {?} */
        builders.get(key);

        if (!!updateFn) {
          updateFn(value);
          this.subject.next({
            element: element,
            key: key,
            value: value
          });
        }
      }
    }
    /**
     * release all references to a given element
     * @param {?} element
     * @return {?}
     */

  }, {
    key: "releaseElement",
    value: function releaseElement(element) {
      /** @type {?} */
      var watcherMap = this.watcherMap.get(element);

      if (watcherMap) {
        watcherMap.forEach(
        /**
        * @param {?} s
        * @return {?}
        */
        function (s) {
          return s.unsubscribe();
        });
        this.watcherMap.delete(element);
      }
      /** @type {?} */


      var elementMap = this.elementMap.get(element);

      if (elementMap) {
        elementMap.forEach(
        /**
        * @param {?} _
        * @param {?} s
        * @return {?}
        */
        function (_, s) {
          return elementMap.delete(s);
        });
        this.elementMap.delete(element);
      }
    }
    /**
     * trigger an update for a given element and key (e.g. layout)
     * @param {?} element
     * @param {?=} key
     * @return {?}
     */

  }, {
    key: "triggerUpdate",
    value: function triggerUpdate(element, key) {
      var _this23 = this;

      /** @type {?} */
      var bpMap = this.elementMap.get(element);

      if (bpMap) {
        /** @type {?} */
        var valueMap = this.getActivatedValues(bpMap, key);

        if (valueMap) {
          if (key) {
            this.updateElement(element, key, valueMap.get(key));
          } else {
            valueMap.forEach(
            /**
            * @param {?} v
            * @param {?} k
            * @return {?}
            */
            function (v, k) {
              return _this23.updateElement(element, k, v);
            });
          }
        }
      }
    }
    /**
     * Cross-reference for HTMLElement with directive key
     * @private
     * @param {?} element
     * @param {?} key
     * @return {?}
     */

  }, {
    key: "buildElementKeyMap",
    value: function buildElementKeyMap(element, key) {
      /** @type {?} */
      var keyMap = this.elementKeyMap.get(element);

      if (!keyMap) {
        keyMap = new Set();
        this.elementKeyMap.set(element, keyMap);
      }

      keyMap.add(key);
    }
    /**
     * Other triggers that should force style updates:
     * - directionality
     * - layout changes
     * - mutationobserver updates
     * @private
     * @param {?} element
     * @param {?} key
     * @param {?} triggers
     * @return {?}
     */

  }, {
    key: "watchExtraTriggers",
    value: function watchExtraTriggers(element, key, triggers) {
      var _this24 = this;

      if (triggers && triggers.length) {
        /** @type {?} */
        var watchers = this.watcherMap.get(element);

        if (!watchers) {
          watchers = new Map();
          this.watcherMap.set(element, watchers);
        }
        /** @type {?} */


        var subscription = watchers.get(key);

        if (!subscription) {
          /** @type {?} */
          var newSubscription = rxjs__WEBPACK_IMPORTED_MODULE_13__.merge.apply(void 0, (0,E_teams_rma_web_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(triggers)).subscribe(
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            var currentValue = _this24.getValue(element, key);

            _this24.updateElement(element, key, currentValue);
          });
          watchers.set(key, newSubscription);
        }
      }
    }
    /**
     * Breakpoint locator by mediaQuery
     * @private
     * @param {?} query
     * @return {?}
     */

  }, {
    key: "findByQuery",
    value: function findByQuery(query) {
      return this.breakpoints.findByQuery(query);
    }
    /**
     * get the fallback breakpoint for a given element, starting with the current breakpoint
     * @private
     * @param {?} bpMap
     * @param {?=} key
     * @return {?}
     */

  }, {
    key: "getActivatedValues",
    value: function getActivatedValues(bpMap, key) {
      for (var i = 0; i < this.activatedBreakpoints.length; i++) {
        /** @type {?} */
        var activatedBp = this.activatedBreakpoints[i];
        /** @type {?} */

        var valueMap = bpMap.get(activatedBp.alias);

        if (valueMap) {
          if (key === undefined || valueMap.has(key) && valueMap.get(key) != null) {
            return valueMap;
          }
        }
      }
      /** @type {?} */


      var lastHope = bpMap.get('');
      return key === undefined || lastHope && lastHope.has(key) ? lastHope : undefined;
    }
    /**
     * Watch for mediaQuery breakpoint activations
     * @private
     * @return {?}
     */

  }, {
    key: "observeActivations",
    value: function observeActivations() {
      /** @type {?} */
      var target =
      /** @type {?} */

      /** @type {?} */
      this;
      /** @type {?} */

      var queries = this.breakpoints.items.map(
      /**
      * @param {?} bp
      * @return {?}
      */
      function (bp) {
        return bp.mediaQuery;
      });
      this.matchMedia.observe(this.hook.withPrintQuery(queries)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.tap)(this.hook.interceptEvents(target)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(this.hook.blockPropagation())).subscribe(this.onMediaChange.bind(this));
    }
  }]);

  return MediaMarshaller;
}();

MediaMarshaller.ɵfac = function MediaMarshaller_Factory(t) {
  return new (t || MediaMarshaller)(_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](MatchMedia), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](BreakPointRegistry), _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"](PrintHook));
};
/** @nocollapse */


MediaMarshaller.ctorParameters = function () {
  return [{
    type: MatchMedia
  }, {
    type: BreakPointRegistry
  }, {
    type: PrintHook
  }];
};
/** @nocollapse */


MediaMarshaller.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵdefineInjectable"])({
  factory: function MediaMarshaller_Factory() {
    return new MediaMarshaller((0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(MatchMedia), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(BreakPointRegistry), (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵɵinject"])(PrintHook));
  },
  token: MediaMarshaller,
  providedIn: "root"
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_8__["ɵsetClassMetadata"](MediaMarshaller, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_8__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: MatchMedia
    }, {
      type: BreakPointRegistry
    }, {
      type: PrintHook
    }];
  }, null);
})();
/**
 * @param {?} map
 * @param {?} element
 * @param {?} key
 * @param {?=} input
 * @return {?}
 */


function initBuilderMap(map$$1, element, key, input) {
  if (input !== undefined) {
    /** @type {?} */
    var oldMap = map$$1.get(element);

    if (!oldMap) {
      oldMap = new Map();
      map$$1.set(element, oldMap);
    }

    oldMap.set(key, input);
  }
}
/**
 * @fileoverview added by tsickle
 * Generated from: core/public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: core/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */




/***/ }),

/***/ 1989:
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm/internal/operators/debounceTime.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debounceTime": function() { return /* binding */ debounceTime; }
/* harmony export */ });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/async */ 6936);
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ 1944);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ 3945);



function debounceTime(dueTime) {
  var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.asyncScheduler;
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;

    var emit = function emit() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };

    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();

      if (now < targetTime) {
        activeTask = this.schedule(undefined, targetTime - now);
        subscriber.add(activeTask);
        return;
      }

      emit();
    }

    source.subscribe(new _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.OperatorSubscriber(subscriber, function (value) {
      lastValue = value;
      lastTime = scheduler.now();

      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function () {
      emit();
      subscriber.complete();
    }, undefined, function () {
      lastValue = activeTask = null;
    }));
  });
}

/***/ })

}]);
//# sourceMappingURL=default-node_modules_angular_flex-layout___ivy_ngcc___esm2015_core_js.js.map